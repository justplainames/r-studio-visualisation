---
title: "csc3007-cyan2"
author: "ONG ZHEN YU BRANDON, GOH BOON CHUN, CHNG JUN JIE JEREMY, EISEN REINER BAGUILAT PERDIDO, MAGESHWARAN SO MUTHUSAMY"
format: html
number-sections: true
knitr:
  opts_chunk:
    fig.width: 7.5
    fig.height: 5
    fig.align: center
    out.width: 100%
---

```{r}
library(readr)
library(ggplot2)
library(e1071)
library(readxl)
library(gridExtra)
library(tidyverse)
library(countrycode)
library(sf)
library(tmap)
library(lintr)
library(plotly)
library(MASS) # for boxcox normalisation
```

```{r}
### Read data
# https://unstats-undesa.opendata.arcgis.com/datasets/undesa::indicator-3-9-2-mortality-rate-attributed-to-unsafe-water-unsafe-sanitation-and-lack-of-hygiene-deaths-per-100-000-population/explore?location=4.310115%2C1.385045%2C3.26
death_water_hygiene <- read_csv("./data/indicator_3.9.2.csv")
# https://unstats-undesa.opendata.arcgis.com/datasets/undesa::indicator-6-1-1-proportion-of-population-using-safely-managed-drinking-water-services-by-urban-rural-percent/explore
water_services_data <- read_csv("./data/indicator_6.1.1.csv")

```

### Merge dataset

```{r}
merged_data <- merge(death_water_hygiene, water_services_data, by=c('geoAreaCode', 'geoAreaName'))
merged_data <- merged_data[!is.na(merged_data$value_2019), ] #remove NA values for 2019
# Display the first few rows of the merged dataframe
merged_data
```


### 1. Scatter plot

```{r}
# Plot the data
plot_loess <- ggplot(merged_data, aes(x = latest_value.x, y = value_2019)) +
  
  geom_point(aes(color = location_desc, 
                 shape = location_desc,
                 text = paste("Country:", geoAreaName, "<br>", "Location:", location_desc)), alpha = 0.7) +
  
  geom_smooth(data = subset(merged_data, location_desc == "All areas"),
              method = loess, se = FALSE, 
              aes(color = location_desc, weight = value_2019),
              show.legend = TRUE) +
  
  geom_smooth(data = subset(merged_data, location_desc == "Urban"),
              method = loess,
              se = FALSE,
              aes(color = location_desc, weight = value_2019),
              show.legend = TRUE) +

  geom_smooth(data = subset(merged_data, location_desc == "Rural"),
              method = loess,
              se = FALSE,
              aes(color = location_desc, weight = value_2019),
              show.legend = TRUE) +
  
  labs(x = "Mortality Rate (deaths per 100,000 population)",
       y = "Safely Managed Drinking Water Services (%)",
       title = "Correlation between Mortality Rate and Water Services (2019)",
       color = "Location Type",
       shape = "Location Type") +
  
  theme_minimal() +
  
  guides(color = guide_legend(override.aes = list(shape = 16)),
         shape = guide_legend(override.aes = list(color = "black")))


# Convert to a plotly plot
gp <- ggplotly(plot_loess, tooltip = "text")

# Print the plot
gp
```

### Correlation Empty Plot
```{r}
correlation_all <- cor(merged_data$latest_value.x[merged_data$location_desc == "All areas"], 
                       merged_data$value_2019[merged_data$location_desc == "All areas"])

correlation_urban <- cor(merged_data$latest_value.x[merged_data$location_desc == "Urban"], 
                         merged_data$value_2019[merged_data$location_desc == "Urban"])

correlation_rural <- cor(merged_data$latest_value.x[merged_data$location_desc == "Rural"], 
                         merged_data$value_2019[merged_data$location_desc == "Rural"])

blank_plot <- ggplot() +
  theme_void() +
  theme(plot.margin = margin(1, 1, 1, 1, "cm")) +
  annotate("text",
           x = 0.5,
           y = 0.5,
           label = paste("Correlation All:",
                         round(correlation_all, 2), "\n",
                         "Correlation Urban:",
                         round(correlation_urban, 2), "\n",
                         "Correlation Rural:",
                         round(correlation_rural, 2)),
           size = 5,
           color = "black",
           hjust = 0.5)

# Convert to a plotly plot
gp_text <- ggplotly(blank_plot)
gp_text
```


### 1.5 Histogram (without Transformation)
```{r}
# Convert the latest_value.x variable into a categorical variable
merged_data$latest_value.x_cat <- cut(merged_data$latest_value.x, breaks = 10)

# Create a stacked bar chart
stacked_bar_chart <- ggplot(merged_data, aes(x = latest_value.x_cat, fill = location_desc)) +
  geom_bar(position = "stack") +
  labs(x = "Mortality Rate (deaths per 100,000 population)",
       y = "Count",
       title = "Stacked Bar Chart of Mortality Rates") +
  theme_minimal()

# Convert to a plotly plot
ggplot_stacked_bar_chart <- ggplotly(stacked_bar_chart)

# Print the plot
print(ggplot_stacked_bar_chart)

# Create a grouped bar chart
grouped_bar_chart <- ggplot(merged_data, aes(x = latest_value.x_cat, fill = location_desc)) +
  geom_bar(position = "dodge") +
  labs(x = "Mortality Rate (deaths per 100,000 population)",
       y = "Count",
       title = "Grouped Bar Chart of Mortality Rates") +
  theme_minimal()

# Convert to a plotly plot
ggplot_grouped_bar_chart <- ggplotly(grouped_bar_chart)

# Print the plot
ggplot_grouped_bar_chart
```

### Normalise Data using BoxCox
```{r}
merged_data$latest_value.x_positive <- merged_data$latest_value.x + abs(min(merged_data$latest_value.x)) + 0.1

# Apply the Box-Cox transformation
bc_result <- boxcox(merged_data$latest_value.x_positive ~ 1, 
                    lambda = seq(-3,3,0.1))

# The optimal lambda value is the one that maximizes the log-likelihood
optimal_lambda <- bc_result$x[which.max(bc_result$y)]
print(paste("Optimal lambda value: ", optimal_lambda))

# Transform the data using the optimal lambda value
if (optimal_lambda == 0) {
  merged_data$latest_value.x_bc <- log(merged_data$latest_value.x_positive)
} else {
  merged_data$latest_value.x_bc <- (merged_data$latest_value.x_positive^optimal_lambda - 1) / optimal_lambda
}

# Shift the transformed variable to be non-negative
min_value <- min(merged_data$latest_value.x_bc)
merged_data$latest_value.x_bc <- merged_data$latest_value.x_bc + abs(min_value) + 0.1

```
```{r}
plot_loess <- ggplot(merged_data, aes(x = latest_value.x_bc, y = value_2019)) +
  
  geom_point(aes(color = location_desc, 
                 shape = location_desc,
                 text = paste("Country:", geoAreaName, "<br>", "Location:", location_desc)), alpha = 0.7) +
  
  geom_smooth(data = subset(merged_data, location_desc == "All areas"),
              method = loess, se = FALSE, 
              aes(color = location_desc, weight = value_2019),
              show.legend = TRUE) +
  
  geom_smooth(data = subset(merged_data, location_desc == "Urban"),
              method = loess,
              se = FALSE,
              aes(color = location_desc, weight = value_2019),
              show.legend = TRUE) +

  geom_smooth(data = subset(merged_data, location_desc == "Rural"),
              method = loess,
              se = FALSE,
              aes(color = location_desc, weight = value_2019),
              show.legend = TRUE) +
  
  labs(x = "Transformed Mortality Rate (deaths per 100,000 population)",
       y = "Safely Managed Drinking Water Services (%)",
       title = "Correlation between Transformed Mortality Rate and Water Services (Normalised)",
       color = "Location Type",
       shape = "Location Type") +
  
  theme_minimal() +
  
  guides(color = guide_legend(override.aes = list(shape = 16)),
         shape = guide_legend(override.aes = list(color = "black")))


gp_normalised <- ggplotly(plot_loess, tooltip = "text")
gp_normalised
```

```{r}
correlation_all <- cor(merged_data$latest_value.x_bc[merged_data$location_desc == "All areas"], 
                       merged_data$value_2019[merged_data$location_desc == "All areas"])

correlation_urban <- cor(merged_data$latest_value.x_bc[merged_data$location_desc == "Urban"], 
                         merged_data$value_2019[merged_data$location_desc == "Urban"])

correlation_rural <- cor(merged_data$latest_value.x_bc[merged_data$location_desc == "Rural"], 
                         merged_data$value_2019[merged_data$location_desc == "Rural"])

blank_plot <- ggplot() +
  theme_void() +
  theme(plot.margin = margin(1, 1, 1, 1, "cm")) +
  annotate("text",
           x = 0.5,
           y = 0.5,
           label = paste("Correlation All:",
                         round(correlation_all, 2), "\n",
                         "Correlation Urban:",
                         round(correlation_urban, 2), "\n",
                         "Correlation Rural:",
                         round(correlation_rural, 2)),
           size = 5,
           color = "black",
           hjust = 0.5)

gp_text_normalised <- ggplotly(blank_plot)
gp_text_normalised
```

### Combining normal and unormalised plots
```{r}
combined_plot <- subplot(
  gp, gp_text, 
  gp_normalised, gp_text_normalised, 
  nrows = 2, margin = 0.05
)

# Print the combined plot
combined_plot
```

# Test

```{r}
library(tmaptools)

# Set tmap options to check and fix invalid polygons
tmap_options(check.and.fix = TRUE)


# Read the GeoJSON files
points_geojson <- sf::st_read("data/indicator_6.1.1.geojson")
world_geojson <- sf::st_read("data/WB_Land.geojson")

# Fix World Map File
# Check and repair geometries for countries_sf
world_geojson <- st_make_valid(world_geojson)
world_geojson <- st_wrap_dateline(world_geojson)
polygon <- st_polygon(x = list(rbind(c(-180.0001, 90),
                                     c(-179.9999, 90),
                                     c(-179.9999, -90),
                                     c(-180.0001, -90),
                                     c(-180.0001, 90)))) |>
  st_sfc() |>
  st_set_crs(4326)

world_geojson <- world_geojson |>
  st_difference(polygon)


# Activate interactive mode
tmap_mode("view")

# Reshape the data to long format
points_long <- points_geojson %>%
  pivot_longer(cols = starts_with("value_"), names_to = "year", values_to = "value")

# Create an interactive map with points overlaying the world map
tm <- tm_shape(points_long) +
  tm_basemap() +
  tm_dots(size = "value", col = "value", shape = 19) +
  tm_facets(by = "year", animate = TRUE) +
  tm_credits("Credits: ") +
  tm_layout(legend.position = c("left", "bottom"))
  
tm_view(tm)
```
```{r}
library(shiny)
library(tmap)
library(stringr)

# Read the GeoJSON files
points_geojson <- sf::st_read("data/indicator_6.1.1.geojson")
world_geojson <- sf::st_read("data/WB_Land.geojson")

# Fix World Map File
# Check and repair geometries for world_geojson
world_geojson <- st_make_valid(world_geojson)
world_geojson <- st_wrap_dateline(world_geojson)

# Reshape the data to long format
points_long <- points_geojson %>%
  pivot_longer(cols = starts_with("value_"), names_to = "year", values_to = "value")

# Remove "year_" prefix
points_long$year <- substring(points_long$year, 6)

# Convert to date format
points_long$year <- as.Date(points_long$year, format = "%Y")

# Define UI
ui <- fluidPage(
  fluidRow(
    column(width = 8,
           tmapOutput("map")
    ),
    column(width = 4,
           sliderInput("year", "Select Year",
                       min = 2000,
                       max = 2020,
                       value = 2000,
                       step = 1
           )
    )
  )
)

# Define server
server <- function(input, output) {
  output$map <- renderTmap({
    # Create map
    tm_shape(points_long) +
      tm_basemap() +
      #tm_polygons(col = "value", palette = "Blues", title = "Value") +
      tm_symbols(size = "value", col = NA , shape = 19, size.adjustment = "zoom")
      #tm_credits("Credits: ") +
      #tm_layout(legend.position = c("left", "bottom"))
  })
}

# Run the application
shinyApp(ui, server)
```

```{r}
library(shiny)
library(tmap)
library(stringr)
library(leaflet)

# Read the GeoJSON files
points_geojson <- sf::st_read("data/indicator_6.1.1.geojson")
world_geojson <- sf::st_read("data/WB_Land.geojson")

# Fix World Map File
# Check and repair geometries for world_geojson
world_geojson <- st_make_valid(world_geojson)
world_geojson <- st_wrap_dateline(world_geojson)

# Reshape the data to long format
points_long <- points_geojson %>%
  pivot_longer(cols = starts_with("value_"), names_to = "year", values_to = "value")

# Remove "year_" prefix
points_long$year <- substring(points_long$year, 6)

# Convert to date format
points_long$year <- as.Date(points_long$year, format = "%Y")

# Define UI
ui <- fluidPage(
  fluidRow(
    column(width = 8,
           tmapOutput("map")
    ),
    column(width = 4,
           sliderInput("year", "Select Year",
                       min = 2000,
                       max = 2020,
                       value = 2000,
                       step = 1
           )
    )
  )
)

# Define server
server <- function(input, output) {
  output$map <- renderLeaflet({
    # Filter data based on selected year
    filtered_data <- subset(points_long, year == input$year)
    
    # Create map
    leaflet() %>%
      addTiles() %>%
      addPolygons(data = world_geojson) %>%
      addCircleMarkers(data = points_long, 
                       radius = ~sqrt(value), 
                       color = "blue", 
                       fillOpacity = 0.8) %>%
      setView(lng = 0, lat = 0, zoom = 2)
  })
}

# Run the application
shinyApp(ui, server)
```
```{r}
filtered_data <- subset(points_long, year == year)
filtered_data
```

