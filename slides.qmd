---
title: "Team Cyan 2"
author: "Ong Zhen Yu Brandon, Goh Boon Chun, Chng Jun Jie Jeremy, Eisen Reiner Baguilat Perdido, Mageshwaran SO Muthusamy"
format:
  revealjs: 
    slide-number: true
    reference-location: document
    transition: slide
    background-transition: fade
    theme: [default, styles.scss]
date: 2023/07/28
date-format: "DD MMMM YYYY"
---

```{r}
#| warning: false
#| message: false
library(readr)
library(ggplot2)
library(e1071)
library(readxl)
library(gridExtra)
library(tidyverse)
library(countrycode)
library(sf)
library(tmap)
library(lintr)
library(plotly)
library(MASS) # for boxcox normalisation
library(rmapshaper)
library(mapview)
library(leaflet)
library(RColorBrewer)
library(DT)
library(GGally)
library(dplyr)
library(psych)
```

# Relationship between Safe Drinking Water and Community Well-being


## Purpose of this presentation

The purpose of this presentation is to examine the relationship between indicators of good health and well-being, specifically targeting the reduction of deaths and illnesses caused by hazardous chemicals, air, water, soil pollution, and contamination. 

The presentation will explore the significance of these indicators and potential strategies for achieving improvements in this area.


## Research Questions

- To what extent does exposure to hazardous chemicals and pollution influence mortality and illness rates?
- Specifically, what is the relationship between access to safe and affordable drinking water and the proportion of population using safe drinking water services?
- How does the availability of sanitation and hygiene facilities, particularly targeting women, affect the mortality rate attributed to unsafe water and hygiene?
- What are the key factors contributing to unintentional poisoning mortality, and how can they be mitigated?

## Importance of this research

- **Public health impact** <br>
  Addresses hazardous chemicals, pollution, and unsafe water's effect on mortality and illness rates.

- **Sustainable Development Goals** <br>
  Supports Goal 3 by focusing on reducing deaths and illnesses from pollution.

- **Policy implications** <br>
  Informs targeted strategies to address health risks.

- **Well-being enhancement** <br>
  Contributes to promoting healthier lives and well-being.


## UN Sustainable Development Goals

Health and water indicators are related to Goals 3 and 6.

![](images/indicators.png){.absolute left=30 bottom=-40}


## UN Targets Addressed

. . .

- **Good Health and Well-being**

  - Target 3.9: Reduce the number of deaths and illnesses from hazardous chemicals and air, water and soil pollution and contamination

. . .

- **Clean Water and Sanitation**
  - Target 6.1: Achieve universal and equitable access to safe and affordable drinking water for all
  - Target 6.2: Achieve adequate and equitable sanitation and hygiene targeting women


## Selected Indicators

. . .

- **Target 3.9.2** Mortality rate attributed to unsafe water, unsafe sanitation and lack of hygiene (exposure to unsafe Water, Sanitation and Hygiene for All (WASH) services) 

. . .

- **Target 3.9.3** Mortality rate attributed to unintentional poisoning 

. . .

- **Target 6.1.1** Proportion of population using safely managed drinking water services 

. . . 

- **Target 6.2.1** Proportion of population using (a) safely managed sanitation services and (b) a hand-washing facility with soap and water


```{r}
#mortality_rate_attributed_to_unsafe_water
mortality_rate_unsafe_water <- read_csv("data/indicator_3.9.2.csv",show_col_types = FALSE)

#Proportion_of_population_using_safely_managed_drinking_water_services
proportion_of_safe_water<- read_csv("data/indicator_6.1.1.csv",show_col_types = FALSE)

#mortality_rate_unintentional_poisoning
mortality_rate_unintentional_poisoning <- read_csv("data/indicator_3.9.3.csv",show_col_types = FALSE)

#proportion-of-population-with-basic-handwashing-facilities-on-premises-by-urban-rural-percent
population_with_basic_handwashing_facilities<- read_csv("data/indicator_6.2.1.csv",show_col_types = FALSE)
```

## Map: Safely managed sanitation, hand-washing proportion (6.2.1): All areas

```{r}
mortality_rate_unintentional_poisoning <- dplyr::select(
  mortality_rate_unintentional_poisoning,
  code = 'geoAreaCode',
  country = 'geoAreaName',
  region = 'parentName',
  iso = 'ISO3',
  gender = 'sex_desc',
  mortality_rate_unintentional_poisoning_2019 = 'value_2019'
)

# drop rows if contains at least one NA value
mortality_rate_unintentional_poisoning <- na.omit(mortality_rate_unintentional_poisoning)

# check for empty row
# any(is.na(mortality_rate_unintentional_poisoning))

# Create histogram of mortality rate unintential poisoning for year 2019
mortality_histo <- ggplot(mortality_rate_unintentional_poisoning, aes(x=mortality_rate_unintentional_poisoning_2019)) +
  geom_histogram(binwidth=0.1, fill='blue', color='black') +
  labs(title="Mortality rate unintentional poisoning for Year 2019", x="Mortality Rate (per 100,000)", y="Number of Country")

# Select specific columns for population with basic handwashing facilities
population_with_basic_handwashing_facilities <- dplyr::select(
  population_with_basic_handwashing_facilities,
  code = 'geoAreaCode',
  country = 'geoAreaName',
  region = 'parentName',
  iso = 'ISO3',
  area = 'location_desc',
  pop_with_basic_handwashing_facilites_2019 = 'value_2019'
)

# drop rows if contains at least one NA value
population_with_basic_handwashing_facilities <- na.omit(population_with_basic_handwashing_facilities)

# check for empty row
# any(is.na(mortality_rate_unintentional_poisoning))


# Create histogram of population with basic handwashing facilities for year 2019
pop_with_handwashing_facilities_histo <- ggplot(population_with_basic_handwashing_facilities, aes(x=pop_with_basic_handwashing_facilites_2019)) +
  geom_histogram(binwidth=5, fill='blue', color='black') +
  labs(title="Population with basic handwashing facilities for Year 2019", x="Population (%)", y="Number of Country")


# Left join between mortality rate and basic handwashing
countries_tb <- left_join(
  mortality_rate_unintentional_poisoning,
  population_with_basic_handwashing_facilities,
  by = join_by(country, iso)
) |>
  mutate(
    iso = case_match(
      iso,
      "COD" ~ "ZAR",
      "ROU" ~ "ROM",
      "TLS" ~ "TMP",
      "XKX" ~ "KSV",
      .default = iso
    )
  )

# import map

countries_sf <- read_sf("./data/WB_countries_Admin0.geojson")
land_sf <- read_sf("./data/WB_Land.geojson")

countries_sf <-
  countries_sf |>
  ms_simplify() |> # Default argument `keep = 0.05`
  st_make_valid()
land_sf <- ms_simplify(land_sf)

countries_sf <-
  countries_sf |>
  left_join(
    countries_tb,
    by = join_by(WB_A3 == iso)
  ) |>
  dplyr::select(country, continent = 'CONTINENT', gender = 'gender', area = 'area', iso = WB_A3, mortality_rate_unintentional_poisoning_2019, pop_with_basic_handwashing_facilites_2019)


polygon <- st_polygon(x = list(rbind(
  c(-180.0001, 90),
  c(-179.9999, 90),
  c(-179.9999, -90),
  c(-180.0001, -90),
  c(-180.0001, 90)
))) |>
  st_sfc() |>
  st_set_crs(4326) # Equirectangular projection
countries_sf <- mutate(
  countries_sf,
  geometry = st_difference(geometry, polygon)
) |>
  st_make_valid()

# tm_shape(countries_sf) + tm_polygons()

countries_sf$area <- replace_na(countries_sf$area, "missing")

choropleth_pop <-
  tm_shape(land_sf, projection = "ESRI:54012") +
  tm_polygons(col = "grey") +
  tm_shape(countries_sf) +
  tm_polygons(
    col = "pop_with_basic_handwashing_facilites_2019",
    border.col = "grey30",
    palette = "Greens",
    breaks = c(-Inf, 20, 40, 60, 80, 100, Inf),
    colorNA = "grey",
    title = "Population (%)",
    lwd = 0.5
  ) +
  tm_text("iso", size = "AREA") +  # Use the new column to set the size
  tm_credits(
    c("", "Source: unstats-undesa.opendata.arcgis.com"),
    position = c("right", "bottom")
  ) +
  tm_layout(
    bg.color = "lightblue",
    frame = FALSE,
    inner.margins = c(0.00, 0.2, 0.2, 0.1),
    earth.boundary = TRUE,
    space.color = "white",
    main.title.size = 0.8,
    title.size = 0.5,
    main.title = "Population with basic handwashing facilities by Country for 2019"
  )

# uncomment to render non interactive map
# choropleth_pop

countries_sf$gender <- replace_na(countries_sf$gender, "missing")
choropleth_mor<-
  tm_shape(land_sf, projection = "ESRI:54012") +
  tm_polygons(col = "grey") +
  tm_shape(countries_sf) +
  tm_polygons(
    col = "mortality_rate_unintentional_poisoning_2019",
    border.col = "grey30",
    palette = "Oranges",
    breaks = c(-Inf, 0.2, 0.4, 0.6, 0.8, 1, Inf),
    colorNA = "grey",
    title = "Mortality Rate \nper 100,000",
    lwd = 0.5
  ) + 
  tm_text("iso", size = "AREA") +
  tm_credits(
    c("", "Source: unstats-undesa.opendata.arcgis.com"),
    position = c("right", "bottom")
  ) +
  tm_layout(
    bg.color = "lightblue",
    frame = FALSE,
    inner.margins = c(0.00, 0.2, 0.2, 0.1),
    earth.boundary = TRUE,
    space.color = "white",
    main.title.size = 0.8,
    title.size = 0.5,
    main.title = "Mortality Rate Unintentional Poisoning by Country for 2019"
  )

# uncomment to render non interactive map
# choropleth_mor

countries_sf_all_areas <- countries_sf[countries_sf$area == "All areas",]
countries_sf_urban <- countries_sf[countries_sf$area == "Urban",]
countries_sf_rural <- countries_sf[countries_sf$area == "Rural",]

# uncomment to view tibbles
# countries_sf_all_areas
# countries_sf_urban
# countries_sf_rural

# Get a color palette with three colors
colors <- brewer.pal(3, "Set1")

# Assign colors to the categories
colorpal_area <- colorFactor(colors, 
                               levels = c("All areas", "Urban", "Rural"))
```

```{r}
# Map of population with basic handwashing facilities for all areas

leaflet(countries_sf_all_areas) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(fillColor = ~colorpal_area(area),  
              fillOpacity = 0.8,
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "3",
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                dashArray = "",
                fillOpacity = 0.7,
                bringToFront = TRUE),
              label = ~iso,  
              popup = ~paste("Country Code: ", iso,
                             "<br>Country: ", country,
                             "<br>Population with basic handwashing facilities (%): ", pop_with_basic_handwashing_facilites_2019,
                             "<br>Area: ", area)) %>%
  addLegend(pal = colorpal_area, 
            values = ~area, 
            title = "Area", 
            position = "bottomright")

```


## Map: Safely managed sanitation, hand-washing proportion (6.2.1): Urban areas

```{r}
leaflet(countries_sf_urban) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(fillColor = ~colorpal_area(area),  # use colorpal_area here
              fillOpacity = 0.8,
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "3",
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                dashArray = "",
                fillOpacity = 0.7,
                bringToFront = TRUE),
              label = ~iso,  # This adds labels that appear when you hover over a country
              popup = ~paste("Country Code: ", iso,
                             "<br>Country: ", country,
                             "<br>Population with basic handwashing facilities (%): ", pop_with_basic_handwashing_facilites_2019,
                             "<br>Area: ", area)) %>%
  addLegend(pal = colorpal_area, 
            values = ~area, 
            title = "Area", 
            position = "bottomright")
```


## Map: Safely managed sanitation, hand-washing proportion (6.2.1): Rural areas

```{r}
leaflet(countries_sf_rural) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(fillColor = ~colorpal_area(area),  # use colorpal_area here
              fillOpacity = 0.8,
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "3",
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                dashArray = "",
                fillOpacity = 0.7,
                bringToFront = TRUE),
              label = ~iso,  # This adds labels that appear when you hover over a country
              popup = ~paste("Country Code: ", iso,
                             "<br>Country: ", country,
                             "<br>Population with basic handwashing facilities (%): ", pop_with_basic_handwashing_facilites_2019,
                             "<br>Area: ", area)) %>%
  addLegend(pal = colorpal_area, 
            values = ~area, 
            title = "Area", 
            position = "bottomright")
```


## Map: Unintentional poisoning mortality rate (3.9.3): Male

```{r}
# Filtering of genders

countries_sf_male <- countries_sf[countries_sf$gender == "Male",]
countries_sf_female <- countries_sf[countries_sf$gender == "Female",]
countries_sf_both <- countries_sf[countries_sf$gender == "Both sexes",]

# uncomment to view tibbles
# countries_sf_male
# countries_sf_female
# countries_sf_both

# Get a color palette with three colors
colors <- brewer.pal(3, "Set1")

# Assign colors to the categories
colorpal_gender <- colorFactor(colors, 
                               levels = c("Female", "Male", "Both sexes"))
```

```{r}
# Replace NAs in 'gender' column
countries_sf_male$gender <- replace_na(countries_sf_male$gender, "missing")

leaflet(countries_sf_male) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(fillColor = ~colorpal_gender(gender),  
              fillOpacity = 0.8,
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "3",
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                dashArray = "",
                fillOpacity = 0.7,
                bringToFront = TRUE),
              label = ~iso,  
              popup = ~paste("Country Code: ", iso,
                             "<br>Country: ", country,
                             "<br>Mortality Rate Unintentional Poisoning per 100,000: ", mortality_rate_unintentional_poisoning_2019,
                             "<br>Gender: ", gender)) %>%
  addLegend(pal = colorpal_gender, 
            values = ~gender, 
            title = "Gender", 
            position = "bottomright")
```


## Map: Unintentional poisoning mortality rate (3.9.3): Female

```{r}
# Replace NAs in 'gender' column
countries_sf_female$gender <- replace_na(countries_sf_female$gender, "missing")

leaflet(countries_sf_female) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(fillColor = ~colorpal_gender(gender),  
              fillOpacity = 0.8,
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "3",
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                dashArray = "",
                fillOpacity = 0.7,
                bringToFront = TRUE),
              label = ~iso,  
              popup = ~paste("Country Code: ", iso,
                             "<br>Country: ", country,
                             "<br>Mortality Rate Unintentional Poisoning per 100,000: ", mortality_rate_unintentional_poisoning_2019,
                             "<br>Gender: ", gender)) %>%
  addLegend(pal = colorpal_gender, 
            values = ~gender, 
            title = "Gender", 
            position = "bottomright")
```


## Map: Unintentional poisoning mortality rate (3.9.3): Both genders

```{r}
# Replace NAs in 'gender' column
countries_sf_both$gender <- replace_na(countries_sf_both$gender, "missing")

leaflet(countries_sf_both) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(fillColor = ~colorpal_gender(gender),  # Assign color based on gender
              fillOpacity = 0.8,
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "3",
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                dashArray = "",
                fillOpacity = 0.7,
                bringToFront = TRUE),
              label = ~iso,  
              popup = ~paste("Country Code: ", iso,
                             "<br>Country: ", country,
                             "<br>Mortality Rate Unintentional Poisoning per 100,000: ", mortality_rate_unintentional_poisoning_2019,
                             "<br>Gender: ", gender)) %>%
  addLegend(pal = colorpal_gender, 
            values = ~gender, 
            title = "Gender", 
            position = "bottomright")
```


## Mortality rate vs Population with basic handwashing facilities {.smaller}

::: {.smaller} 
There is a strong negative correlation between Mortality rate and Population with basic handwashing facilities
:::

```{r}
# Plots of Indicator between mortality rate and population with basic handwashing facilities

countries_sf <- countries_sf[!is.na(countries_sf$mortality_rate_unintentional_poisoning_2019) & !is.na(countries_sf$pop_with_basic_handwashing_facilites_2019), ]

countries_sf <- countries_sf %>%
  filter(gender == 'Both sexes')

# uncomment to view tibble
# countries_sf

# Plot the data
plot_loess <- ggplot(countries_sf, aes(x = mortality_rate_unintentional_poisoning_2019, y = pop_with_basic_handwashing_facilites_2019)) +
  
  geom_point(aes(color = area, 
                 shape = area,
                 text = paste("Country:", country, "<br>", "Location:", area)), alpha = 0.7) +
  
  geom_smooth(data = subset(countries_sf, area == "All areas"),
              method = loess, se = FALSE,
              aes(color = area, weight = pop_with_basic_handwashing_facilites_2019),
              show.legend = TRUE) +
  
  geom_smooth(data = subset(countries_sf, area == "Urban"),
              method = loess, se = FALSE,
              aes(color = area, weight = pop_with_basic_handwashing_facilites_2019),
              show.legend = TRUE) +

  geom_smooth(data = subset(countries_sf, area == "Rural"),
              method = loess, se = FALSE,
              aes(color = area, weight = pop_with_basic_handwashing_facilites_2019),
              show.legend = TRUE) +
  
  labs(x = "Mortality Rate (deaths per 100,000 population) for 2019 ",
       y = "Population with Basic Handwashing Facilities for 2019 (%)",
       title = "Correlation between Mortality Rate and Basic Handwashing Facilities \n for Both Gender",
       color = "Location Type",
       shape = "Location Type") +
  
  theme_minimal() +
  
  guides(color = guide_legend(override.aes = list(shape = 16)),
         shape = guide_legend(override.aes = list(color = "black")))


# Convert to a plotly plot
gp_map_1 <- ggplotly(plot_loess, tooltip = "text")

# gp_map_1
```

```{r}
correlation_all <- cor(countries_sf$pop_with_basic_handwashing_facilites_2019[countries_sf$area == "All areas"], 
                       countries_sf$mortality_rate_unintentional_poisoning_2019[countries_sf$area == "All areas"])

correlation_urban <- cor(countries_sf$pop_with_basic_handwashing_facilites_2019[countries_sf$area == "Urban"], 
                         countries_sf$mortality_rate_unintentional_poisoning_2019[countries_sf$area == "Urban"])

correlation_rural <- cor(countries_sf$pop_with_basic_handwashing_facilites_2019[countries_sf$area == "Rural"], 
                         countries_sf$mortality_rate_unintentional_poisoning_2019[countries_sf$area == "Rural"])

blank_plot <- ggplot() +
  theme_void() +
  theme(plot.margin = margin(1, 1, 1, 1, "cm")) +
  annotate("text",
           x = 0.5,
           y = 0.5,
           label = paste("Correlation All:",
                         round(correlation_all, 2), "\n",
                         "Correlation Urban:",
                         round(correlation_urban, 2), "\n",
                         "Correlation Rural:",
                         round(correlation_rural, 2)),
           size = 5,
           color = "black",
           hjust = 0.5)

# Convert to a plotly plot
gp_text_map_1 <- ggplotly(blank_plot)

# gp_text_map_1
```

```{r}
#| warning: false
stacked_bar_chart <- ggplot(countries_sf, aes(x = mortality_rate_unintentional_poisoning_2019, fill = area)) +
  geom_bar(position = "stack") +
  labs(x = "Mortality Rate (deaths per 100,000 population)",
       y = "Count",
       title = "Stacked Bar Chart of Mortality Rates") +
  theme_minimal()

# Convert to a plotly plot
ggplot_stacked_bar_chart <- ggplotly(stacked_bar_chart)

# Create a grouped bar chart
grouped_bar_chart <- ggplot(countries_sf, aes(x = mortality_rate_unintentional_poisoning_2019, fill = area)) +
  geom_bar(position = "dodge") +
  labs(x = "Mortality Rate (deaths per 100,000 population)",
       y = "Count",
       title = "Grouped Bar Chart of Mortality Rates") +
  theme_minimal()

# Convert to a plotly plot
ggplot_grouped_bar_chart <- ggplotly(grouped_bar_chart)

```

```{r}
# Barchart and stacked barchart (without Transformation)
ggplot_stacked_bar_chart <- ggplotly(stacked_bar_chart, width = 1000, height = 600, autosize = TRUE)
ggplot_grouped_bar_chart <- ggplotly(grouped_bar_chart, width = 1000, height = 600, autosize = TRUE)

# ggplot_stacked_bar_chart
# ggplot_grouped_bar_chart
```

```{r}
#| include: false
# Normalise Data
#Ensure you have the MASS library installed

countries_sf$mortality_rate_unintentional_poisoning_2019.positive <- countries_sf$mortality_rate_unintentional_poisoning_2019 + abs(min(countries_sf$mortality_rate_unintentional_poisoning_2019)) + 0.1
# Apply the Box-Cox transformation
bc_result <- MASS::boxcox(countries_sf$mortality_rate_unintentional_poisoning_2019.positive ~ 1, 
                    lambda = seq(-3,3,0.1))

# The optimal lambda value is the one that maximizes the log-likelihood
optimal_lambda <- bc_result$x[which.max(bc_result$y)]

# Transform the data using the optimal lambda value
if (optimal_lambda == 0) {
  countries_sf$latest_value.x_bc <- log(countries_sf$mortality_rate_unintentional_poisoning_2019.positive)
} else {
  countries_sf$latest_value.x_bc <- (countries_sf$mortality_rate_unintentional_poisoning_2019.positive^optimal_lambda - 1) / optimal_lambda
}

# Shift the transformed variable to be non-negative
min_value <- min(countries_sf$latest_value.x_bc)
countries_sf$latest_value.x_bc <- countries_sf$latest_value.x_bc + abs(min_value) + 0.1

```

```{r}
# Histogram (Normalised)

# Round the transformed mortality rates to the nearest whole number
countries_sf$latest_value.x_bc_rounded <- round(countries_sf$latest_value.x_bc)

# Convert the latest_value.x_bc_rounded variable into a categorical variable
countries_sf$latest_value.x_bc_cat <- cut(countries_sf$latest_value.x_bc_rounded, breaks = 50)

# Create a stacked bar chart
stacked_bar_chart_bc <- ggplot(countries_sf, aes(x = latest_value.x_bc_rounded, fill = area)) +
  geom_bar(position = "stack", bins =20) +
  labs(x = "Transformed Mortality Rate",
       y = "Count",
       title = "Stacked Bar Chart of Transformed Mortality Rates") +
  theme_minimal()

ggplot_stacked_bar_chart_bc <- ggplotly(stacked_bar_chart_bc)
# ggplot_stacked_bar_chart_bc

# Create a grouped bar chart
grouped_bar_chart_bc <- ggplot(countries_sf, aes(x = latest_value.x_bc_rounded, fill = area)) +
  geom_bar(position = "dodge") +
  labs(x = "Transformed Mortality Rate",
       y = "Count",
       title = "Grouped Bar Chart of Transformed Mortality Rates") +
  theme_minimal()

# Convert to a plotly plot
ggplot_grouped_bar_chart_bc <- ggplotly(grouped_bar_chart_bc)
# ggplot_grouped_bar_chart_bc
```

```{r}
# Scatter plot Normalised

plot_loess <- ggplot(countries_sf, aes(x = latest_value.x_bc, y = pop_with_basic_handwashing_facilites_2019)) +
  
  geom_point(aes(color = area, 
                 shape = area,
                 text = paste("Country:", country, "<br>", "Location:", area)), alpha = 0.7) +
  
  geom_smooth(data = subset(countries_sf, area == "All areas"),
              method = loess, se = FALSE, 
              aes(color = area, weight = pop_with_basic_handwashing_facilites_2019),
              show.legend = TRUE) +
  
  geom_smooth(data = subset(countries_sf, area == "Urban"),
              method = loess,
              se = FALSE,
              aes(color = area, weight = pop_with_basic_handwashing_facilites_2019),
              show.legend = TRUE) +

  geom_smooth(data = subset(countries_sf, area == "Rural"),
              method = loess,
              se = FALSE,
              aes(color = area, weight = pop_with_basic_handwashing_facilites_2019),
              show.legend = TRUE) +
  
  labs(x = "Transformed Mortality Rate (deaths per 100,000 population) for 2019",
       y = "Population with Basic Handwashing Facilities for 2019 (%)",
       title = "Correlation between Mortality Rate and Basic Handwashing Facilities (Normalised) for Both Gender",
       color = "Location Type",
       shape = "Location Type") +
  
  theme_minimal() +
  
  guides(color = guide_legend(override.aes = list(shape = 16)),
         shape = guide_legend(override.aes = list(color = "black")))


gp_normalised_map_1 <- ggplotly(plot_loess, tooltip = "text")
# gp_normalised_map_1
```

```{r}
# Correlation Normalised

correlation_all <- cor(countries_sf$latest_value.x_bc[countries_sf$area == "All areas"], 
                       countries_sf$pop_with_basic_handwashing_facilites_2019[countries_sf$area == "All areas"])

correlation_urban <- cor(countries_sf$latest_value.x_bc[countries_sf$area == "Urban"], 
                         countries_sf$pop_with_basic_handwashing_facilites_2019[countries_sf$area == "Urban"])

correlation_rural <- cor(countries_sf$latest_value.x_bc[countries_sf$area == "Rural"], 
                         countries_sf$pop_with_basic_handwashing_facilites_2019[countries_sf$area == "Rural"])

blank_plot <- ggplot() +
  theme_void() +
  theme(plot.margin = margin(1, 1, 1, 1, "cm")) +
  annotate("text",
           x = 0.5,
           y = 0.5,
           label = paste("Correlation All:",
                         round(correlation_all, 2), "\n",
                         "Correlation Urban:",
                         round(correlation_urban, 2), "\n",
                         "Correlation Rural:",
                         round(correlation_rural, 2)),
           size = 5,
           color = "black",
           hjust = 0.5)

gp_text_normalised_map_1 <- ggplotly(blank_plot)
# gp_text_normalised_map_1
```

```{r}
# Combining normal and unormalised plots

combined_plot_map_1 <- subplot(
  gp_map_1, gp_text_map_1, 
  gp_normalised_map_1, gp_text_normalised_map_1, 
  nrows = 2, margin = 0.05
)

# Print the combined plot
combined_plot_map_1
```


## Mortality rate vs Population with basic handwashing facilities


```{r}
subplot <- subplot(ggplot_stacked_bar_chart, ggplot_grouped_bar_chart, nrows = 1)
subplot
```

## Mortality rate vs Population with basic handwashing facilities (Normalised)

```{r}
subplot_normalised <- subplot(ggplot_stacked_bar_chart_bc, ggplot_grouped_bar_chart_bc, nrows = 1)
subplot_normalised
```


## Map: Safely managed drinking water proportion (6.1.1): All areas

```{r}
proportion_of_safe_water_map <- dplyr::select(
  proportion_of_safe_water,
  code = 'geoAreaCode',
  country = 'geoAreaName',
  region = 'parentName',
  iso = 'ISO3',
  urbanisation = "location_desc",
  value_2019 = "value_2019"
)

proportion_of_safe_water_map <- proportion_of_safe_water_map%>%
  distinct()

# proportion_of_safe_water_map
```

```{r}
mortality_rate_unsafe_water_map <- dplyr::select(
  mortality_rate_unsafe_water,
  code = 'geoAreaCode',
  country = 'geoAreaName',
  region = 'parentName',
  iso = 'ISO3',
  mortality_rate_unsafe_water = 'latest_value'
)

mortality_rate_unsafe_water_map <- mortality_rate_unsafe_water_map%>%
  distinct()

# mortality_rate_unsafe_water_map
```


```{r}
# Cleaning and fixing geometry data

countries_geom <- read_sf("./data/WB_countries_Admin0.geojson")
countries_boundary <- st_boundary(countries_geom)
countries_sf_simplified <- ms_simplify(countries_boundary, keep = 0.05)
countries_sf_valid <- st_make_valid(countries_sf_simplified)
countries_wrapped <- st_wrap_dateline(countries_sf_valid)
polygon <- st_polygon(x = list(rbind(c(-180.0001, 90),
                                     c(-179.9999, 90),
                                     c(-179.9999, -90),
                                     c(-180.0001, -90),
                                     c(-180.0001, 90)))) |>
  st_sfc() |>
  st_set_crs(4326)

countries_wrapped <- countries_wrapped |>
  st_difference(polygon)


land_sf <- read_sf("data/WB_Land.geojson")
land_boundary <- st_boundary(land_sf)
land_sf_simplified <- ms_simplify(land_boundary, keep = 0.05)
land_sf_valid <- st_make_valid(land_sf_simplified)
land_wrapped <- st_wrap_dateline(land_sf_valid)
polygon <- st_polygon(x = list(rbind(c(-180.0001, 90),
                                     c(-179.9999, 90),
                                     c(-179.9999, -90),
                                     c(-180.0001, -90),
                                     c(-180.0001, 90)))) |>
  st_sfc() |>
  st_set_crs(4326)

land_wrapped <- land_wrapped |>
  st_difference(polygon)

countries_wrapped <- countries_wrapped |>
  st_difference(polygon)
```

```{r}
# Washing data combined
countries_sf_water <- left_join(
    countries_wrapped,
  proportion_of_safe_water_map,
  by = c("WB_A3" = "iso")
)
# countries_sf_water

# Mortality Rate Combined
countries_sf_mortality <- left_join(
    countries_wrapped,
  mortality_rate_unsafe_water_map,
  by = c("WB_A3" = "iso")
)

# countries_sf_mortality
```


```{r}
# Get the different values for all areas, urban and rural in water management

countries_sf_water_all <- countries_sf_water %>% filter(!(urbanisation %in% c("Rural","Urban")))
countries_sf_water_urban <- countries_sf_water %>% filter(!(urbanisation %in% c("All area","Urban")))
countries_sf_water_rural <- countries_sf_water %>% filter(!(urbanisation %in% c("Urban","All areas")))
```

```{r}
# Load the required libraries
library(leaflet)

# Define the color palette function
colorPalette <- colorRampPalette(c("#FF6969", "#00A0D6"))


# Generate the color palette based on the number of breaks
numBreaks <- 6
colors <- colorPalette(numBreaks)

# Create a Leaflet map
all_map <- leaflet(countries_sf_water_all) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(fillColor = ~colorNumeric(palette=colors, domain = c(0, 20, 40, 60, 80, 100))(value_2019),  
              fillOpacity = 0.8,
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "3",
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                dashArray = "",
                fillOpacity = 0.7,
                bringToFront = TRUE),
              label = ~WB_A3,  
              popup = ~paste("Country Code: ", WB_A3,
                             "<br>Country: ", country,
                             "<br>Proportion of population access to safely managed drinking water service: ", value_2019))%>%
  addLegend(
    position = "bottomright",
    pal = colorNumeric(palette = colors, domain = c(0, 100)),
    values = c(0, 20, 40, 60, 80, 100),
    title = "Proportion (%)",
    labels = c("0-20", "20-40", "40-60", "60-80", "80-100"),
    opacity = 1
  )

all_map
```


## Map: Safely managed drinking water proportion (6.1.1): Urban areas

```{r}
# Define the color palette function
colorPalette <- colorRampPalette(c("#FF6969", "#00A0D6"))


# Generate the color palette based on the number of breaks
numBreaks <- 6
colors <- colorPalette(numBreaks)

# Create a Leaflet map
urban_map <- leaflet(countries_sf_water_urban) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(fillColor = ~colorNumeric(palette=colors, domain = c(0, 20, 40, 60, 80, 100))(value_2019),  
              fillOpacity = 0.8,
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "3",
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                dashArray = "",
                fillOpacity = 0.7,
                bringToFront = TRUE),
              label = ~WB_A3,
              popup = ~paste("Country Code: ", WB_A3,
                             "<br>Country: ", country,
                             "<br>Proportion of population access to safely managed drinking water service: ", value_2019))%>%
  addLegend(
    position = "bottomright",
    pal = colorNumeric(palette = colors, domain = c(0, 100)),
    values = c(0, 20, 40, 60, 80, 100),
    title = "Proportion (%)",
    labels = c("0-20", "20-40", "40-60", "60-80", "80-100"),
    opacity = 1
  )

urban_map
```

## Map: Safely managed drinking water proportion (6.1.1): Rural areas

```{r}
# Define the color palette function
colorPalette <- colorRampPalette(c("#FF6969", "#00A0D6"))


# Generate the color palette based on the number of breaks
numBreaks <- 6
colors <- colorPalette(numBreaks)

# Create a Leaflet map
rural_map <- leaflet(countries_sf_water_rural) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(fillColor = ~colorNumeric(palette=colors, domain = c(0, 20, 40, 60, 80, 100))(value_2019),  
              fillOpacity = 0.8,
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "3",
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                dashArray = "",
                fillOpacity = 0.7,
                bringToFront = TRUE),
              label = ~WB_A3,  
              popup = ~paste("Country Code: ", WB_A3,
                             "<br>Country: ", country,
                             "<br>Proportion of population access to safely managed drinking water service: ", value_2019))%>%
  addLegend(
    position = "bottomright",
    pal = colorNumeric(palette = colors, domain = c(0, 100)),
    values = c(0, 20, 40, 60, 80, 100),
    title = "Proportion (%)",
    labels = c("0-20", "20-40", "40-60", "60-80", "80-100"),
    opacity = 1
  )

rural_map
```

## Map: Water, sanitation, hygiene mortality rate (3.9.2)

```{r}

# Define the color palette function
colorPalette <- colorRampPalette(c("#FFFFDF", "#FFEEAA", "#FFBB55", "#FF7700", "#FF4400"))


# Generate the color palette based on the number of breaks
numBreaks <- 6
colors <- colorPalette(numBreaks)

# Create a Leaflet map
mortality_mapping <- leaflet(countries_sf_mortality) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(fillColor = ~colorNumeric(palette=colors, domain = c(0, 20, 40, 60, 80, 100))(mortality_rate_unsafe_water),  
              fillOpacity = 0.8,
              weight = 2,
              opacity = 1,
              color = "grey",
              dashArray = "3",
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                dashArray = "",
                fillOpacity = 0.7,
                bringToFront = TRUE),
              label = ~WB_A3,  
              popup = ~paste("Country Code: ", WB_A3,
                             "<br>Country: ", country,
                             "<br>Mortality Rate from Unsafe Sanitation and Water per 100,000: ", mortality_rate_unsafe_water))%>%
  addLegend(
    position = "bottomright",
    pal = colorNumeric(palette = colors, domain = c(0, 100)),
    values = c(0, 20, 40, 60, 80, 100),
    title = "Proportion (100, 000)",
    labels = c("0-20", "20-40", "40-60", "60-80", "80-100"),
    opacity = 1
  )

mortality_mapping
```


## Mortality Rate vs Water Services

```{r}
merged_data <- merge(mortality_rate_unsafe_water, proportion_of_safe_water, by=c('geoAreaCode', 'geoAreaName'))
merged_data <- merged_data[!is.na(merged_data$value_2019), ] #remove NA values for 2019
# Display the first few rows of the merged dataframe
# head(merged_data)
```

```{r}
# Correlation

# Plot the data
plot_loess <- ggplot(merged_data, aes(x = latest_value.x, y = value_2019)) +
  
  geom_point(aes(color = location_desc, 
                 shape = location_desc,
                 text = paste("Country:", geoAreaName, "<br>", "Location:", location_desc)), alpha = 0.7) +
  
  geom_smooth(data = subset(merged_data, location_desc == "All areas"),
              method = loess, se = FALSE, 
              aes(color = location_desc, weight = value_2019),
              show.legend = TRUE) +
  
  geom_smooth(data = subset(merged_data, location_desc == "Urban"),
              method = loess,
              se = FALSE,
              aes(color = location_desc, weight = value_2019),
              show.legend = TRUE) +

  geom_smooth(data = subset(merged_data, location_desc == "Rural"),
              method = loess,
              se = FALSE,
              aes(color = location_desc, weight = value_2019),
              show.legend = TRUE) +
  
  labs(x = "Mortality Rate (deaths per 100,000 population)",
       y = "Safely Managed Drinking Water Services (%)",
       title = "Correlation between Mortality Rate and Water Services (2019)",
       color = "Location Type",
       shape = "Location Type") +
  
  theme_minimal() +
  
  guides(color = guide_legend(override.aes = list(shape = 16)),
         shape = guide_legend(override.aes = list(color = "black")))


# Convert to a plotly plot
gp <- ggplotly(plot_loess, tooltip = "text")

# Print the plot
# gp
```

```{r}
correlation_all <- cor(merged_data$latest_value.x[merged_data$location_desc == "All areas"], 
                       merged_data$value_2019[merged_data$location_desc == "All areas"])

correlation_urban <- cor(merged_data$latest_value.x[merged_data$location_desc == "Urban"], 
                         merged_data$value_2019[merged_data$location_desc == "Urban"])

correlation_rural <- cor(merged_data$latest_value.x[merged_data$location_desc == "Rural"], 
                         merged_data$value_2019[merged_data$location_desc == "Rural"])

blank_plot <- ggplot() +
  theme_void() +
  theme(plot.margin = margin(1, 1, 1, 1, "cm")) +
  annotate("text",
           x = 0.5,
           y = 0.5,
           label = paste("Correlation All:",
                         round(correlation_all, 2), "\n",
                         "Correlation Urban:",
                         round(correlation_urban, 2), "\n",
                         "Correlation Rural:",
                         round(correlation_rural, 2)),
           size = 5,
           color = "black",
           hjust = 0.5)

# Convert to a plotly plot
gp_text <- ggplotly(blank_plot)
# gp_text
```

```{r}
# Barchart and stacked barchart (without Transformation)

stacked_bar_chart <- ggplot(merged_data, aes(x = latest_value.x, fill = location_desc)) +
  geom_histogram(position = "stack", bins = 20) +
  labs(x = "Mortality Rate (deaths per 100,000 population)",
       y = "Count",
       title = "Stacked Bar Chart of Mortality Rates") +
  theme_minimal()

#change to plotly
ggplot_stacked_bar_chart <- ggplotly(stacked_bar_chart)
# ggplot_stacked_bar_chart

grouped_bar_chart <- ggplot(merged_data, aes(x = latest_value.x, fill = location_desc)) +
  geom_histogram(position = "dodge", bins = 20) +
  labs(x = "Mortality Rate (deaths per 100,000 population)",
       y = "Count",
       title = "Grouped Bar Chart of Mortality Rates") +
  theme_minimal()

# Convert to a plotly plot
ggplot_grouped_bar_chart <- ggplotly(grouped_bar_chart)
# ggplot_grouped_bar_chart
```

```{r}
# Filter data for the histogram
merged_data_all<- subset(merged_data, location_desc == "All areas")  # change to rural or urban if you want

histogram <- ggplot(merged_data_all, aes(x = latest_value.x, 
                             text = paste("Country:", geoAreaName, 
                                          "<br>Mortality Rate:", latest_value.x))) +
  geom_histogram(bins = 50, fill = 'grey', color = 'black') +
  labs(x = 'Mortality Rate (deaths per 100,000 population)',
       y = 'Count',
       title = 'Histogram of Mortality Rates for "All" locations') +
  theme_minimal()

# Convert ggplot histogram to a plotly plot
plotly_histogram <- ggplotly(histogram, tooltip = "text")
```

```{r}
#| include: false

# Normalise Data 

merged_data$latest_value.x_positive <- merged_data$latest_value.x + abs(min(merged_data$latest_value.x)) + 0.1

# Apply the Box-Cox transformation
bc_result <- MASS::boxcox(merged_data$latest_value.x_positive ~ 1, 
                    lambda = seq(-3,3,0.1))

# The optimal lambda value is the one that maximizes the log-likelihood
optimal_lambda <- bc_result$x[which.max(bc_result$y)]

# Transform the data using the optimal lambda value
if (optimal_lambda == 0) {
  merged_data$latest_value.x_bc <- log(merged_data$latest_value.x_positive)
} else {
  merged_data$latest_value.x_bc <- (merged_data$latest_value.x_positive^optimal_lambda - 1) / optimal_lambda
}

# Shift the transformed variable to be non-negative
min_value <- min(merged_data$latest_value.x_bc)
merged_data$latest_value.x_bc <- merged_data$latest_value.x_bc + abs(min_value) + 0.1

```

```{r}
# Histogram (Normalised)

# Round the transformed mortality rates to the nearest whole number
merged_data$latest_value.x_bc_rounded <- round(merged_data$latest_value.x_bc)

# Convert the latest_value.x_bc_rounded variable into a categorical variable
merged_data$latest_value.x_bc_cat <- cut(merged_data$latest_value.x_bc_rounded, breaks = 50)

# Create a stacked bar chart
stacked_bar_chart_bc <- ggplot(merged_data, aes(x = latest_value.x_bc_rounded, fill = location_desc)) +
  geom_bar(position = "stack", bins =20) +
  labs(x = "Transformed Mortality Rate",
       y = "Count",
       title = "Stacked Bar Chart of Transformed Mortality Rates") +
  theme_minimal()

ggplot_stacked_bar_chart_bc <- ggplotly(stacked_bar_chart_bc)
# ggplot_stacked_bar_chart_bc

# Create a grouped bar chart
grouped_bar_chart_bc <- ggplot(merged_data, aes(x = latest_value.x_bc_rounded, fill = location_desc)) +
  geom_bar(position = "dodge") +
  labs(x = "Transformed Mortality Rate",
       y = "Count",
       title = "Grouped Bar Chart of Transformed Mortality Rates") +
  theme_minimal()

# Convert to a plotly plot
ggplot_grouped_bar_chart_bc <- ggplotly(grouped_bar_chart_bc)
# ggplot_grouped_bar_chart_bc
```

```{r}
# Scatter plot Normalised
plot_loess <- ggplot(merged_data, aes(x = latest_value.x_bc, y = value_2019)) +
  
  geom_point(aes(color = location_desc, 
                 shape = location_desc,
                 text = paste("Country:", geoAreaName, "<br>", "Location:", location_desc)), alpha = 0.7) +
  
  geom_smooth(data = subset(merged_data, location_desc == "All areas"),
              method = loess, se = FALSE, 
              aes(color = location_desc, weight = value_2019),
              show.legend = TRUE) +
  
  geom_smooth(data = subset(merged_data, location_desc == "Urban"),
              method = loess,
              se = FALSE,
              aes(color = location_desc, weight = value_2019),
              show.legend = TRUE) +

  geom_smooth(data = subset(merged_data, location_desc == "Rural"),
              method = loess,
              se = FALSE,
              aes(color = location_desc, weight = value_2019),
              show.legend = TRUE) +
  
  labs(x = "Transformed Mortality Rate (deaths per 100,000 population)",
       y = "Safely Managed Drinking Water Services (%)",
       title = "Correlation between Transformed Mortality Rate and Water Services (Normalised)",
       color = "Location Type",
       shape = "Location Type") +
  
  theme_minimal() +
  
  guides(color = guide_legend(override.aes = list(shape = 16)),
         shape = guide_legend(override.aes = list(color = "black")))


gp_normalised <- ggplotly(plot_loess, tooltip = "text")
# gp_normalised
```

```{r}
# Correlation normalised
correlation_all <- cor(merged_data$latest_value.x_bc[merged_data$location_desc == "All areas"], 
                       merged_data$value_2019[merged_data$location_desc == "All areas"])

correlation_urban <- cor(merged_data$latest_value.x_bc[merged_data$location_desc == "Urban"], 
                         merged_data$value_2019[merged_data$location_desc == "Urban"])

correlation_rural <- cor(merged_data$latest_value.x_bc[merged_data$location_desc == "Rural"], 
                         merged_data$value_2019[merged_data$location_desc == "Rural"])

blank_plot <- ggplot() +
  theme_void() +
  theme(plot.margin = margin(1, 1, 1, 1, "cm")) +
  annotate("text",
           x = 0.5,
           y = 0.5,
           label = paste("Correlation All:",
                         round(correlation_all, 2), "\n",
                         "Correlation Urban:",
                         round(correlation_urban, 2), "\n",
                         "Correlation Rural:",
                         round(correlation_rural, 2)),
           size = 5,
           color = "black",
           hjust = 0.5)

gp_text_normalised <- ggplotly(blank_plot)
# gp_text_normalised
```

```{r}
# Combining normal and unnormalised plots

combined_plot <- subplot(
  gp, gp_text, 
  gp_normalised, gp_text_normalised, 
  nrows = 2, margin = 0.05
)

combined_plot
```


## Mortality Rate vs Water Services


```{r}
subplot <- subplot(ggplot_stacked_bar_chart, ggplot_grouped_bar_chart, nrows = 1)
subplot
```

## Mortality Rate vs Water Services (Normalised)

```{r}
subplot_normalised <- subplot(ggplot_stacked_bar_chart_bc, ggplot_grouped_bar_chart_bc, nrows = 1)
subplot_normalised
```



## Table of all countries representation {.smaller .scrollable}

```{r}
#mortality_rate_attributed_to_unsafe_water
mortality_rate_unsafe_water_indicators <- read_csv("data/indicator_3.9.2.csv",show_col_types = FALSE)

#Proportion_of_population_using_safely_managed_drinking_water_services
proportion_of_safe_water_indicators<- read_csv("data/indicator_6.1.1.csv",show_col_types = FALSE)

#mortality_rate_unintentional_poisoning
mortality_rate_unintentional_poisoning_indicators <- read_csv("data/indicator_3.9.3.csv",show_col_types = FALSE)

#proportion-of-population-with-basic-handwashing-facilities-on-premises-by-urban-rural-percent
population_with_basic_handwashing_facilities_indicators <- read_csv("data/indicator_6.2.1.csv",show_col_types = FALSE)
```

```{r}
mortality_rate_unsafe_water_indicators <- dplyr::select(
  mortality_rate_unsafe_water_indicators,
  code = 'geoAreaCode',
  country = 'geoAreaName',
  region = 'parentName',
  iso = 'ISO3',
  MR_unsafe_water = 'latest_value'
)

mortality_rate_unsafe_water_indicators <- mortality_rate_unsafe_water_indicators %>%
  distinct()

# mortality_rate_unsafe_water_indicators
```

```{r}
proportion_of_safe_water_indicators <- dplyr::select(
  proportion_of_safe_water_indicators,
  code = 'geoAreaCode',
  country = 'geoAreaName',
  region = 'parentName',
  iso = 'ISO3',
  urbanisation = "location_desc",
  sanitation_access = "value_2019",
)

# Remove duplicates
proportion_of_safe_water_indicators <- proportion_of_safe_water_indicators%>%
  distinct()

# proportion_of_safe_water_indicators
```

```{r}
#| label: select specific columns for mortality rate
mortality_rate_unintentional_poisoning_indicators <- dplyr::select(
  mortality_rate_unintentional_poisoning_indicators,
  code = 'geoAreaCode',
  country = 'geoAreaName',
  region = 'parentName',
  iso = 'ISO3',
  gender = 'sex_desc',
  MR_poisoning = 'value_2019'
)

# drop rows if contains at least one NA value
mortality_rate_unintentional_poisoning_indicators <- na.omit(mortality_rate_unintentional_poisoning_indicators)

# Remove duplicates
mortality_rate_unintentional_poisoning_indicators <- mortality_rate_unintentional_poisoning_indicators%>%
  distinct()

# check for empty row
# any(is.na(mortality_rate_unintentional_poisoning_indicators))

# mortality_rate_unintentional_poisoning_indicators
```

```{r}
#| label: select specific columns for population with basic handwashing facilities
population_with_basic_handwashing_facilities_indicators <- dplyr::select(
  population_with_basic_handwashing_facilities_indicators,
  code = 'geoAreaCode',
  country = 'geoAreaName',
  region = 'parentName',
  iso = 'ISO3',
  urbanisation = 'location_desc',
  handwash_access = 'value_2019'
)

# drop rows if contains at least one NA value
population_with_basic_handwashing_facilities_indicators <- na.omit(population_with_basic_handwashing_facilities_indicators)

# Remove duplicates
population_with_basic_handwashing_facilities_indicators <- population_with_basic_handwashing_facilities_indicators%>%
  distinct()

# check for empty row
# any(is.na(mortality_rate_unintentional_poisoning_indicators))

# population_with_basic_handwashing_facilities_indicators
```


```{r}
#| warning: false

# Joining all 4 indicators

countries_tb <- left_join(
  mortality_rate_unintentional_poisoning_indicators,
  population_with_basic_handwashing_facilities_indicators,
  by = join_by(country, iso)
)
  
countries_tb <- left_join(
  countries_tb,
  mortality_rate_unsafe_water_indicators,
  by = join_by(iso)
) 
  
countries_tb <- left_join(
  countries_tb,
  proportion_of_safe_water_indicators,
  by = join_by(iso, urbanisation)
) |>  
  mutate(
    iso = case_match(
      iso,
      "COD" ~ "ZAR",
      "ROU" ~ "ROM",
      "TLS" ~ "TMP",
      "XKX" ~ "KSV",
      .default = iso
    )
  )

# names(countries_tb)
```


```{r}
# Joining with adminGeoJson

countries_sf <- read_sf("./data/WB_countries_Admin0.geojson")
countries_tb <- left_join(
  countries_tb,
  dplyr::select(countries_sf,WB_A3, GDP_MD_EST, INCOME_GRP, POP_EST),
  by = c("iso" = "WB_A3")
)
```

```{r}
# countries_tb
```

```{r}
#| fig-width: 3.5
#| fig-height: 3.5

# Clean data
# Remove certain columns and rename column for cleaner a look

# Drop
clean_datatable <- dplyr::select(countries_tb, 
                          -code.y, -code.x,
                          -region.y, -region.x,
                          -code.x.x, code.y.y, 
                          -country.x, -country.y,
                          -region.x.x, -region.y.y, 
                          -iso)  
# Rename
clean_datatable <- clean_datatable %>% rename(
  gdp = GDP_MD_EST,
  income_group = INCOME_GRP,
  population = POP_EST)

# Rearrange
clean_datatable <- clean_datatable %>%
  dplyr::select(country,
         gdp,
         income_group,
         population,
         urbanisation, 
         gender, 
         handwash_access,  
         sanitation_access, 
         MR_poisoning, 
         MR_unsafe_water,)
```

```{r}
#| out-width: 25%
datatable(clean_datatable)
```

## Correlation between all 4 indicators

```{r}
# filter gender of both sexes to reduce duplicates
countries_tb <- countries_tb |>
  filter(gender == "Both sexes") |>
  na.omit(countries_tb)
# countries_tb
```

```{r}
countries_tb_subset <- dplyr::select(countries_tb, MR_poisoning, MR_unsafe_water, handwash_access, sanitation_access,urbanisation,country.x)

# Display the subsetted data
# print(countries_tb_subset)
```


```{r}
# Scatterplot matrix

# set axis names
countries_tb_subset_corr4 <- dplyr::select(countries_tb_subset, MR_unsafe_water, MR_poisoning, handwash_access, sanitation_access, urbanisation,country.x)
colnames(countries_tb_subset_corr4) <- c("Unsafe Water Mortality Rate",
                                         "Poisoning Mortality",
                                         "Handwashing Access (%)",
                                         "Sanitation Access (%)",
                                         "Urbanisation",
                                         "Countries"
                                         )
# countries_tb_subset_corr4

# change to factor for colour
countries_tb_subset_corr4$Urbanisation <- as.factor(countries_tb_subset_corr4$Urbanisation)

plot <- ggpairs(data = countries_tb_subset_corr4,
                columns = 1:4,
                upper = list(continuous = "cor"),
                lower = list(continuous = "smooth", se=FALSE),
                diag = list(continuous = "bar", bin=30),
                mapping = aes(color = Urbanisation),
                tooltips = c("Countries")) +
  theme_minimal() +
  theme(axis.title = element_text(size = 5))
  
# plot
```

```{r}
# Convert ggplot to plotly
plot_interactive <- ggplotly(plot)

plot_interactive <- layout(plot_interactive,
       font = list(size = 8)
)

# Render the plotly scatterplot matrix
plot_interactive
```

```{r}
#| include: false

# Different Scatter plot matrix

countries_tb_subset_corr4 <- dplyr::select(countries_tb_subset, MR_unsafe_water, MR_poisoning, handwash_access, sanitation_access, urbanisation)

# Rename the columns
colnames(countries_tb_subset_corr4) <- c("Unsafe Water Mortality Rate", 
                                         "Poisoning Mortality",
                                         "Handwashing Access (%)", 
                                         "Sanitation Access (%)",
                                         "Urbanisation")

# Make urbanisation as a factor for colourisation
countries_tb_subset_corr4$Urbanisation <- as.factor(countries_tb_subset_corr4$Urbanisation)

# Map urbanisation to colors
color_mapping <- c("All areas" = "red", "Urban" = "blue", "Rural" = "green") # Adjust to your actual factor levels and desired colors
colors <- color_mapping[countries_tb_subset_corr4$Urbanisation]

# Create scatterplot matrix without colors
plot <- pairs.panels(countries_tb_subset_corr4[, 1:4],
                     hist.col = "#00AFBB",
                     bg = "transparent")
```

## $\textit{k}$-Means Clustering

Considering the four selected Sustainable Development Goals, what is an appropriate number, $\textit{k}$, of clusters for countries?

::: columns

::: {.column width="35%"}
*diagram here*
:::

::: {.column width="3%"}
:::

::: {.column width="62%"}
The 'xxx' suggests $k=3$ or $k=4$.

We choose $k=3$, but this decision is admittedly subjective.
:::

:::


## Pairs Plot Highlighting Clusters

::: columns

::: {.column width="35%"}
*diagram here*
:::

::: {.column width="3%"}
:::

::: {.column width="62%"}

::: {style="color: red;"}
1. High xxx and high xxx representation. 
:::

::: {style="color: blue;"}
2. Low xxx and high xxx representation.
:::

::: {style="color: green;"}
3. Low xxx representation.
:::

:::

:::


## Decision Tree

Can the cluster assignment be predicted based on the country’s income group, population size and region according to the 7-class World Bank categorisation?

*diagram here*


## Evaluation of Decision Tree

::: {style="color: red;"}
CHANGE THIS
:::

The decision tree does not assign any country to cluster 2 (low education and high political representation).

Ten-fold cross validation indicates that the decision tree has a low accuracy of 0.65.

The relative importance of the predictors for classification are as follows:

- Income group: 100
- Region: 60.55
- Population size: 9.07


## Summary of Quantitative Results

- Strong positive correlations exist between indicators for the same goal.
- Moderate but statistically significant correlations are observed between indicators for different goals.
- The country’s income group and region may moderately influence female participation in education and politics.
- Population size does not have a significant impact.
- Many missing. Only 72 countries have data for all four indicators.


## Policy Implications

- Education and gender equality indicators are interconnected.
- Promote gender equality in both national and local political institutions because both levels are strongly correlated.
- Tailor interventions to address specific challenges in different income groups and regions.
- Support countries in improving data collection for evidence-based policymaking.

# End