---
title: "Team Cyan 2"
author: "Ong Zhen Yu Brandon, Goh Boon Chun, Chng Jun Jie Jeremy, Eisen Reiner Baguilat Perdido, Mageshwaran SO Muthusamy"
format:
  revealjs: 
    slide-number: true
    reference-location: document
    transition: slide
    background-transition: fade
    theme: [default, styles.scss]
date: 2023/07/28
date-format: "DD MMMM YYYY"
---

```{r}
#| warning: false
#| message: false
library(readr)
library(ggplot2)
library(e1071)
library(readxl)
library(gridExtra)
library(tidyverse)
library(countrycode)
library(sf)
library(tmap)
library(lintr)
library(plotly)
library(MASS) # for boxcox normalisation
library(rmapshaper)
library(mapview)
library(leaflet)
library(RColorBrewer)
library(DT)
library(GGally)
library(dplyr)
library(psych)
library(knitr)
library(factoextra)
library(GGally)
library(data.table)
library(rpart)
library(rpart.plot)
library(rattle)
library(caret)
```

# Relationship between Safe Drinking Water and Community Well-being


## Purpose of this presentation

The purpose of this presentation is to examine the relationship between indicators of good health and well-being, specifically targeting the reduction of deaths and illnesses caused by hazardous chemicals, air, water, soil pollution, and contamination. 

The presentation will explore the significance of these indicators and potential strategies for achieving improvements in this area.


## Research Questions

- To what extent does exposure to hazardous chemicals and pollution influence mortality and illness rates?
- Specifically, what is the relationship between access to safe and affordable drinking water and the proportion of population using safe drinking water services?
- How does the availability of sanitation and hygiene facilities, particularly targeting women, affect the mortality rate attributed to unsafe water and hygiene?
- What are the key factors contributing to unintentional poisoning mortality, and how can they be mitigated?

## Importance of this research

- **Public health impact** <br>
  Addresses hazardous chemicals, pollution, and unsafe water's effect on mortality and illness rates.

- **Sustainable Development Goals** <br>
  Supports Goal 3 by focusing on reducing deaths and illnesses from pollution.

- **Policy implications** <br>
  Informs targeted strategies to address health risks.

- **Well-being enhancement** <br>
  Contributes to promoting healthier lives and well-being.


## UN Sustainable Development Goals

Health and water indicators are related to Goals 3 and 6.

![](images/indicators.png){.absolute left=30 bottom=-40}


## UN Targets Addressed

. . .

- **Good Health and Well-being**

  - Target 3.9: Reduce the number of deaths and illnesses from hazardous chemicals and air, water and soil pollution and contamination

. . .

- **Clean Water and Sanitation**
  - Target 6.1: Achieve universal and equitable access to safe and affordable drinking water for all
  - Target 6.2: Achieve adequate and equitable sanitation and hygiene targeting women


## Selected Indicators

. . .

- **Target 3.9.2** Mortality rate attributed to unsafe water, unsafe sanitation and lack of hygiene (exposure to unsafe Water, Sanitation and Hygiene for All (WASH) services) 

. . .

- **Target 3.9.3** Mortality rate attributed to unintentional poisoning 

. . .

- **Target 6.1.1** Proportion of population using safely managed drinking water services 

. . . 

- **Target 6.2.1** Proportion of population using (a) safely managed sanitation services and (b) a hand-washing facility with soap and water


```{r}
# mortality_rate_attributed_to_unsafe_water
mortality_rate_unsafe_water <- read_csv("data/indicator_3.9.2.csv",
  show_col_types = FALSE
)

# safely_managed_drinking_water_services
proportion_of_safe_water <- read_csv("data/indicator_6.1.1.csv",
  show_col_types = FALSE
)

# unintentional_poisoning
unintentional_poisoning <- read_csv("data/indicator_3.9.3.csv",
  show_col_types = FALSE
)

# proportion-of-population-with-basic-handwashing-facilities
basic_handwashing_facilities <-
  read_csv("data/indicator_6.2.1.csv",
    show_col_types = FALSE
  )
```

## Map: Managed sanitation, hand-washing proportion (6.2.1): All areas

```{r}
unintentional_poisoning <- dplyr::select(
  unintentional_poisoning,
  code = "geoAreaCode",
  country = "geoAreaName",
  region = "parentName",
  iso = "ISO3",
  gender = "sex_desc",
  unintentional_poisoning_2019 = "value_2019"
)

# drop rows if contains at least one NA value
unintentional_poisoning <- na.omit(unintentional_poisoning)

# Histogram of mortality rate unintential poisoning
mortality_histo <- ggplot(
  unintentional_poisoning,
  aes(x = unintentional_poisoning_2019)
) +
  geom_histogram(binwidth = 0.1, fill = "blue", color = "black") +
  labs(
    title = "Mortality rate unintentional poisoning for Year 2019",
    x = "Mortality Rate (per 100,000)",
    y = "Number of Country"
  )

# Select specific columns for population with basic handwashing facilities
basic_handwashing_facilities <- dplyr::select(
  basic_handwashing_facilities,
  code = "geoAreaCode",
  country = "geoAreaName",
  region = "parentName",
  iso = "ISO3",
  area = "location_desc",
  pop_with_basic_handwashing_facilites_2019 = "value_2019"
)

# drop rows if contains at least one NA value
basic_handwashing_facilities <- na.omit(basic_handwashing_facilities)

# histogram of basic handwashing facilities
handwashing_facilities_histo <- ggplot(
  basic_handwashing_facilities,
  aes(x = pop_with_basic_handwashing_facilites_2019)
) +
  geom_histogram(
    binwidth = 5,
    fill = "blue",
    color = "black"
  ) +
  labs(
    title = "Population with basic handwashing facilities for Year 2019",
    x = "Population (%)",
    y = "Number of Country"
  )


# Left join between mortality rate and basic handwashing
countries_tb <- left_join(
  unintentional_poisoning,
  basic_handwashing_facilities,
  by = join_by(country, iso)
) |>
  mutate(
    iso = case_match(
      iso,
      "COD" ~ "ZAR",
      "ROU" ~ "ROM",
      "TLS" ~ "TMP",
      "XKX" ~ "KSV",
      .default = iso
    )
  )

# import map

countries_sf <- read_sf("./data/WB_countries_Admin0.geojson")
land_sf <- read_sf("./data/WB_Land.geojson")

countries_sf <-
  countries_sf |>
  ms_simplify() |> # Default argument `keep = 0.05`
  st_make_valid()
land_sf <- ms_simplify(land_sf)

countries_sf <-
  countries_sf |>
  left_join(
    countries_tb,
    by = join_by(WB_A3 == iso)
  ) |>
  dplyr::select(country,
    continent = "CONTINENT",
    gender = "gender",
    area = "area",
    iso = WB_A3,
    unintentional_poisoning_2019,
    pop_with_basic_handwashing_facilites_2019
  )


polygon <- st_polygon(x = list(rbind(
  c(-180.0001, 90),
  c(-179.9999, 90),
  c(-179.9999, -90),
  c(-180.0001, -90),
  c(-180.0001, 90)
))) |>
  st_sfc() |>
  st_set_crs(4326) # Equirectangular projection
countries_sf <- mutate(
  countries_sf,
  geometry = st_difference(geometry, polygon)
) |>
  st_make_valid()

countries_sf$area <- replace_na(countries_sf$area, "missing")

choropleth_pop <-
  tm_shape(land_sf, projection = "ESRI:54012") +
  tm_polygons(col = "grey") +
  tm_shape(countries_sf) +
  tm_polygons(
    col = "pop_with_basic_handwashing_facilites_2019",
    border.col = "grey30",
    palette = "Greens",
    breaks = c(-Inf, 20, 40, 60, 80, 100, Inf),
    colorNA = "grey",
    title = "Population (%)",
    lwd = 0.5
  ) +
  tm_text("iso", size = "AREA") +
  tm_credits(
    c("", "Source: unstats-undesa.opendata.arcgis.com"),
    position = c("right", "bottom")
  ) +
  tm_layout(
    bg.color = "lightblue",
    frame = FALSE,
    inner.margins = c(0.00, 0.2, 0.2, 0.1),
    earth.boundary = TRUE,
    space.color = "white",
    main.title.size = 0.8,
    title.size = 0.5,
    main.title = "Population with basic handwashing facilities by Country for 2019"
  )

# uncomment to render non interactive map
# choropleth_pop

countries_sf$gender <- replace_na(countries_sf$gender, "missing")
choropleth_mor <-
  tm_shape(land_sf, projection = "ESRI:54012") +
  tm_polygons(col = "grey") +
  tm_shape(countries_sf) +
  tm_polygons(
    col = "unintentional_poisoning_2019",
    border.col = "grey30",
    palette = "Oranges",
    breaks = c(-Inf, 0.2, 0.4, 0.6, 0.8, 1, Inf),
    colorNA = "grey",
    title = "Mortality Rate \nper 100,000",
    lwd = 0.5
  ) +
  tm_text("iso", size = "AREA") +
  tm_credits(
    c("", "Source: unstats-undesa.opendata.arcgis.com"),
    position = c("right", "bottom")
  ) +
  tm_layout(
    bg.color = "lightblue",
    frame = FALSE,
    inner.margins = c(0.00, 0.2, 0.2, 0.1),
    earth.boundary = TRUE,
    space.color = "white",
    main.title.size = 0.8,
    title.size = 0.5,
    main.title = "Mortality Rate Unintentional Poisoning by Country for 2019"
  )

# uncomment to render non interactive map
# choropleth_mor

countries_sf_all_areas <- countries_sf[countries_sf$area == "All areas", ]
countries_sf_urban <- countries_sf[countries_sf$area == "Urban", ]
countries_sf_rural <- countries_sf[countries_sf$area == "Rural", ]

# uncomment to view tibbles
# countries_sf_all_areas
# countries_sf_urban
# countries_sf_rural

# Get a color palette with three colors
colors <- brewer.pal(3, "Set1")

# Assign colors to the categories
colorpal_area <- colorFactor(colors,
  levels = c("All areas", "Urban", "Rural")
)
```

```{r}
# Map of population with basic handwashing facilities for all areas

leaflet(countries_sf_all_areas) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    fillColor = ~ colorpal_area(area),
    fillOpacity = 0.8,
    weight = 2,
    opacity = 1,
    color = "white",
    dashArray = "3",
    highlight = highlightOptions(
      weight = 5,
      color = "#666",
      dashArray = "",
      fillOpacity = 0.7,
      bringToFront = TRUE
    ),
    label = ~iso,
    popup = ~ paste(
      "Country Code: ", iso,
      "<br>Country: ", country,
      "<br>Population with basic handwashing facilities (%): ", pop_with_basic_handwashing_facilites_2019,
      "<br>Area: ", area
    )
  ) %>%
  addLegend(
    pal = colorpal_area,
    values = ~area,
    title = "Area",
    position = "bottomright"
  )
```


## Map: Safely managed sanitation, hand-washing proportion (6.2.1): Urban areas

```{r}
leaflet(countries_sf_urban) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    fillColor = ~ colorpal_area(area), # use colorpal_area here
    fillOpacity = 0.8,
    weight = 2,
    opacity = 1,
    color = "white",
    dashArray = "3",
    highlight = highlightOptions(
      weight = 5,
      color = "#666",
      dashArray = "",
      fillOpacity = 0.7,
      bringToFront = TRUE
    ),
    label = ~iso, # This adds labels that appear when you hover over a country
    popup = ~ paste(
      "Country Code: ", iso,
      "<br>Country: ", country,
      "<br>Population with basic handwashing facilities (%): ", pop_with_basic_handwashing_facilites_2019,
      "<br>Area: ", area
    )
  ) %>%
  addLegend(
    pal = colorpal_area,
    values = ~area,
    title = "Area",
    position = "bottomright"
  )
```


## Map: Safely managed sanitation, hand-washing proportion (6.2.1): Rural areas

```{r}
leaflet(countries_sf_rural) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    fillColor = ~ colorpal_area(area), # use colorpal_area here
    fillOpacity = 0.8,
    weight = 2,
    opacity = 1,
    color = "white",
    dashArray = "3",
    highlight = highlightOptions(
      weight = 5,
      color = "#666",
      dashArray = "",
      fillOpacity = 0.7,
      bringToFront = TRUE
    ),
    label = ~iso, # This adds labels that appear when you hover over a country
    popup = ~ paste(
      "Country Code: ", iso,
      "<br>Country: ", country,
      "<br>Population with basic handwashing facilities (%): ", pop_with_basic_handwashing_facilites_2019,
      "<br>Area: ", area
    )
  ) %>%
  addLegend(
    pal = colorpal_area,
    values = ~area,
    title = "Area",
    position = "bottomright"
  )
```


## Map: Unintentional poisoning mortality rate (3.9.3): Male

```{r}
# Filtering of genders

countries_sf_male <- countries_sf[countries_sf$gender == "Male", ]
countries_sf_female <- countries_sf[countries_sf$gender == "Female", ]
countries_sf_both <- countries_sf[countries_sf$gender == "Both sexes", ]

# uncomment to view tibbles
# countries_sf_male
# countries_sf_female
# countries_sf_both

# Get a color palette with three colors
colors <- brewer.pal(3, "Set1")

# Assign colors to the categories
colorpal_gender <- colorFactor(colors,
  levels = c("Female", "Male", "Both sexes")
)
```

```{r}
# Replace NAs in 'gender' column
countries_sf_male$gender <- replace_na(countries_sf_male$gender, "missing")

leaflet(countries_sf_male) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    fillColor = ~ colorpal_gender(gender),
    fillOpacity = 0.8,
    weight = 2,
    opacity = 1,
    color = "white",
    dashArray = "3",
    highlight = highlightOptions(
      weight = 5,
      color = "#666",
      dashArray = "",
      fillOpacity = 0.7,
      bringToFront = TRUE
    ),
    label = ~iso,
    popup = ~ paste(
      "Country Code: ", iso,
      "<br>Country: ", country,
      "<br>Mortality Rate Unintentional Poisoning per 100,000: ", unintentional_poisoning_2019,
      "<br>Gender: ", gender
    )
  ) %>%
  addLegend(
    pal = colorpal_gender,
    values = ~gender,
    title = "Gender",
    position = "bottomright"
  )
```


## Map: Unintentional poisoning mortality rate (3.9.3): Female

```{r}
# Replace NAs in 'gender' column
countries_sf_female$gender <- replace_na(countries_sf_female$gender, "missing")

leaflet(countries_sf_female) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    fillColor = ~ colorpal_gender(gender),
    fillOpacity = 0.8,
    weight = 2,
    opacity = 1,
    color = "white",
    dashArray = "3",
    highlight = highlightOptions(
      weight = 5,
      color = "#666",
      dashArray = "",
      fillOpacity = 0.7,
      bringToFront = TRUE
    ),
    label = ~iso,
    popup = ~ paste(
      "Country Code: ", iso,
      "<br>Country: ", country,
      "<br>Mortality Rate Unintentional Poisoning per 100,000: ", unintentional_poisoning_2019,
      "<br>Gender: ", gender
    )
  ) %>%
  addLegend(
    pal = colorpal_gender,
    values = ~gender,
    title = "Gender",
    position = "bottomright"
  )
```


## Map: Unintentional poisoning mortality rate (3.9.3): Both genders

```{r}
# Replace NAs in 'gender' column
countries_sf_both$gender <- replace_na(countries_sf_both$gender, "missing")

leaflet(countries_sf_both) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    fillColor = ~ colorpal_gender(gender), # Assign color based on gender
    fillOpacity = 0.8,
    weight = 2,
    opacity = 1,
    color = "white",
    dashArray = "3",
    highlight = highlightOptions(
      weight = 5,
      color = "#666",
      dashArray = "",
      fillOpacity = 0.7,
      bringToFront = TRUE
    ),
    label = ~iso,
    popup = ~ paste(
      "Country Code: ", iso,
      "<br>Country: ", country,
      "<br>Mortality Rate Unintentional Poisoning per 100,000: ", unintentional_poisoning_2019,
      "<br>Gender: ", gender
    )
  ) %>%
  addLegend(
    pal = colorpal_gender,
    values = ~gender,
    title = "Gender",
    position = "bottomright"
  )
```


## MR vs Population with basic handwashing facilities {.smaller}

::: {.smaller} 
There is a strong negative correlation between Mortality rate and Population with basic handwashing facilities
:::

```{r}
# Plots of Indicator between mortality rate and population with basic handwashing facilities

countries_sf <- countries_sf[!is.na(countries_sf$unintentional_poisoning_2019) &
  !is.na(countries_sf$pop_with_basic_handwashing_facilites_2019), ]

countries_sf <- countries_sf %>%
  filter(gender == "Both sexes")

# uncomment to view tibble
# countries_sf

# Plot the data
plot_loess <- ggplot(
  countries_sf,
  aes(
    x = unintentional_poisoning_2019,
    y = pop_with_basic_handwashing_facilites_2019
  )
) +
  geom_point(aes(
    color = area,
    shape = area,
    text = paste("Country:", country, "<br>", "Location:", area)
  ), alpha = 0.7) +
  geom_smooth(
    data = subset(countries_sf, area == "All areas"),
    method = loess, se = FALSE,
    aes(color = area, weight = pop_with_basic_handwashing_facilites_2019),
    show.legend = TRUE
  ) +
  geom_smooth(
    data = subset(countries_sf, area == "Urban"),
    method = loess, se = FALSE,
    aes(color = area, weight = pop_with_basic_handwashing_facilites_2019),
    show.legend = TRUE
  ) +
  geom_smooth(
    data = subset(countries_sf, area == "Rural"),
    method = loess, se = FALSE,
    aes(color = area, weight = pop_with_basic_handwashing_facilites_2019),
    show.legend = TRUE
  ) +
  labs(
    x = "Mortality Rate (deaths per 100,000 population) for 2019 ",
    y = "Population with Basic Handwashing Facilities for 2019 (%)",
    title = "Correlation between Mortality Rate and Basic Handwashing Facilities \n for Both Gender",
    color = "Location Type",
    shape = "Location Type"
  ) +
  theme_minimal() +
  guides(
    color = guide_legend(override.aes = list(shape = 16)),
    shape = guide_legend(override.aes = list(color = "black"))
  )


# Convert to a plotly plot
gp_map_1 <- ggplotly(plot_loess, tooltip = "text")

# gp_map_1
```

```{r}
correlation_all <- cor(
  countries_sf$pop_with_basic_handwashing_facilites_2019[countries_sf$area == "All areas"],
  countries_sf$unintentional_poisoning_2019[countries_sf$area == "All areas"]
)

correlation_urban <- cor(
  countries_sf$pop_with_basic_handwashing_facilites_2019[countries_sf$area == "Urban"],
  countries_sf$unintentional_poisoning_2019[countries_sf$area == "Urban"]
)

correlation_rural <- cor(
  countries_sf$pop_with_basic_handwashing_facilites_2019[countries_sf$area == "Rural"],
  countries_sf$unintentional_poisoning_2019[countries_sf$area == "Rural"]
)

blank_plot <- ggplot() +
  theme_void() +
  theme(plot.margin = margin(1, 1, 1, 1, "cm")) +
  annotate("text",
    x = 0.5,
    y = 0.5,
    label = paste(
      "Correlation All:",
      round(correlation_all, 2), "\n",
      "Correlation Urban:",
      round(correlation_urban, 2), "\n",
      "Correlation Rural:",
      round(correlation_rural, 2)
    ),
    size = 5,
    color = "black",
    hjust = 0.5
  )

# Convert to a plotly plot
gp_text_map_1 <- ggplotly(blank_plot)

# gp_text_map_1
```

```{r}
#| warning: false
stacked_bar_chart <- ggplot(countries_sf, aes(x = unintentional_poisoning_2019, fill = area)) +
  geom_bar(position = "stack") +
  labs(
    x = "Mortality Rate (deaths per 100,000 population)",
    y = "Count",
    title = "Stacked Bar Chart of Mortality Rates"
  ) +
  theme_minimal()

# Convert to a plotly plot
ggplot_stacked_bar_chart <- ggplotly(stacked_bar_chart)

# Create a grouped bar chart
grouped_bar_chart <- ggplot(countries_sf, aes(x = unintentional_poisoning_2019, fill = area)) +
  geom_bar(position = "dodge") +
  labs(
    x = "Mortality Rate (deaths per 100,000 population)",
    y = "Count",
    title = "Grouped Bar Chart of Mortality Rates"
  ) +
  theme_minimal()

# Convert to a plotly plot
ggplot_grouped_bar_chart <- ggplotly(grouped_bar_chart)
```

```{r}
# Barchart and stacked barchart (without Transformation)
ggplot_stacked_bar_chart <- ggplotly(stacked_bar_chart, width = 1000, height = 600, autosize = TRUE)
ggplot_grouped_bar_chart <- ggplotly(grouped_bar_chart, width = 1000, height = 600, autosize = TRUE)

# ggplot_stacked_bar_chart
# ggplot_grouped_bar_chart
```

```{r}
#| include: false
# Normalise Data
# Ensure you have the MASS library installed

countries_sf$unintentional_poisoning_2019.positive <- countries_sf$unintentional_poisoning_2019 + abs(min(countries_sf$unintentional_poisoning_2019)) + 0.1
# Apply the Box-Cox transformation
bc_result <- MASS::boxcox(countries_sf$unintentional_poisoning_2019.positive ~ 1,
  lambda = seq(-3, 3, 0.1)
)

# The optimal lambda value is the one that maximizes the log-likelihood
optimal_lambda <- bc_result$x[which.max(bc_result$y)]

# Transform the data using the optimal lambda value
if (optimal_lambda == 0) {
  countries_sf$latest_value.x_bc <- log(countries_sf$unintentional_poisoning_2019.positive)
} else {
  countries_sf$latest_value.x_bc <- (countries_sf$unintentional_poisoning_2019.positive^optimal_lambda - 1) / optimal_lambda
}

# Shift the transformed variable to be non-negative
min_value <- min(countries_sf$latest_value.x_bc)
countries_sf$latest_value.x_bc <- countries_sf$latest_value.x_bc + abs(min_value) + 0.1
```

```{r}
# Histogram (Normalised)

# Round the transformed mortality rates to the nearest whole number
countries_sf$latest_value.x_bc_rounded <- round(countries_sf$latest_value.x_bc)

# Convert the latest_value.x_bc_rounded variable into a categorical variable
countries_sf$latest_value.x_bc_cat <- cut(countries_sf$latest_value.x_bc_rounded, breaks = 50)

# Create a stacked bar chart
stacked_bar_chart_bc <- ggplot(countries_sf, aes(x = latest_value.x_bc_rounded, fill = area)) +
  geom_bar(position = "stack", bins = 20) +
  labs(
    x = "Transformed Mortality Rate",
    y = "Count",
    title = "Stacked Bar Chart of Transformed Mortality Rates"
  ) +
  theme_minimal()

ggplot_stacked_bar_chart_bc <- ggplotly(stacked_bar_chart_bc)
# ggplot_stacked_bar_chart_bc

# Create a grouped bar chart
grouped_bar_chart_bc <- ggplot(countries_sf, aes(x = latest_value.x_bc_rounded, fill = area)) +
  geom_bar(position = "dodge") +
  labs(
    x = "Transformed Mortality Rate",
    y = "Count",
    title = "Grouped Bar Chart of Transformed Mortality Rates"
  ) +
  theme_minimal()

# Convert to a plotly plot
ggplot_grouped_bar_chart_bc <- ggplotly(grouped_bar_chart_bc)
# ggplot_grouped_bar_chart_bc
```

```{r}
# Scatter plot Normalised

plot_loess <- ggplot(countries_sf, aes(x = latest_value.x_bc, y = pop_with_basic_handwashing_facilites_2019)) +
  geom_point(aes(
    color = area,
    shape = area,
    text = paste("Country:", country, "<br>", "Location:", area)
  ), alpha = 0.7) +
  geom_smooth(
    data = subset(countries_sf, area == "All areas"),
    method = loess, se = FALSE,
    aes(color = area, weight = pop_with_basic_handwashing_facilites_2019),
    show.legend = TRUE
  ) +
  geom_smooth(
    data = subset(countries_sf, area == "Urban"),
    method = loess,
    se = FALSE,
    aes(color = area, weight = pop_with_basic_handwashing_facilites_2019),
    show.legend = TRUE
  ) +
  geom_smooth(
    data = subset(countries_sf, area == "Rural"),
    method = loess,
    se = FALSE,
    aes(color = area, weight = pop_with_basic_handwashing_facilites_2019),
    show.legend = TRUE
  ) +
  labs(
    x = "Transformed Mortality Rate (deaths per 100,000 population) for 2019",
    y = "Population with Basic Handwashing Facilities for 2019 (%)",
    title = "Correlation between Mortality Rate and Basic Handwashing Facilities (Normalised) for Both Gender",
    color = "Location Type",
    shape = "Location Type"
  ) +
  theme_minimal() +
  guides(
    color = guide_legend(override.aes = list(shape = 16)),
    shape = guide_legend(override.aes = list(color = "black"))
  )


gp_normalised_map_1 <- ggplotly(plot_loess, tooltip = "text")
# gp_normalised_map_1
```

```{r}
# Correlation Normalised

correlation_all <- cor(
  countries_sf$latest_value.x_bc[countries_sf$area == "All areas"],
  countries_sf$pop_with_basic_handwashing_facilites_2019[countries_sf$area == "All areas"]
)

correlation_urban <- cor(
  countries_sf$latest_value.x_bc[countries_sf$area == "Urban"],
  countries_sf$pop_with_basic_handwashing_facilites_2019[countries_sf$area == "Urban"]
)

correlation_rural <- cor(
  countries_sf$latest_value.x_bc[countries_sf$area == "Rural"],
  countries_sf$pop_with_basic_handwashing_facilites_2019[countries_sf$area == "Rural"]
)

blank_plot <- ggplot() +
  theme_void() +
  theme(plot.margin = margin(1, 1, 1, 1, "cm")) +
  annotate("text",
    x = 0.5,
    y = 0.5,
    label = paste(
      "Correlation All:",
      round(correlation_all, 2), "\n",
      "Correlation Urban:",
      round(correlation_urban, 2), "\n",
      "Correlation Rural:",
      round(correlation_rural, 2)
    ),
    size = 5,
    color = "black",
    hjust = 0.5
  )

gp_text_normalised_map_1 <- ggplotly(blank_plot)
# gp_text_normalised_map_1
```

```{r}
# Combining normal and unormalised plots

combined_plot_map_1 <- subplot(
  gp_map_1, gp_text_map_1,
  gp_normalised_map_1, gp_text_normalised_map_1,
  nrows = 2, margin = 0.05
)

# Print the combined plot
combined_plot_map_1
```


## Mortality rate vs Population with basic handwashing facilities


```{r}
subplot <- subplot(ggplot_stacked_bar_chart, ggplot_grouped_bar_chart, nrows = 1)
subplot
```

## Mortality rate vs Population with basic handwashing facilities (Normalised)

```{r}
subplot_normalised <- subplot(ggplot_stacked_bar_chart_bc, ggplot_grouped_bar_chart_bc, nrows = 1)
subplot_normalised
```


## Map: Safely managed drinking water proportion (6.1.1): All areas

```{r}
proportion_of_safe_water_map <- dplyr::select(
  proportion_of_safe_water,
  code = "geoAreaCode",
  country = "geoAreaName",
  region = "parentName",
  iso = "ISO3",
  urbanisation = "location_desc",
  value_2019 = "value_2019"
)

proportion_of_safe_water_map <- proportion_of_safe_water_map %>%
  distinct()

# proportion_of_safe_water_map
```

```{r}
mr_unsafe_water_map <- dplyr::select(
  mortality_rate_unsafe_water,
  code = "geoAreaCode",
  country = "geoAreaName",
  region = "parentName",
  iso = "ISO3",
  mortality_rate_unsafe_water = "latest_value"
)

mr_unsafe_water_map <- mr_unsafe_water_map %>%
  distinct()

# mr_unsafe_water_map
```


```{r}
# Cleaning and fixing geometry data

countries_geom <- read_sf("./data/WB_countries_Admin0.geojson")
countries_boundary <- st_boundary(countries_geom)
countries_sf_simplified <- ms_simplify(countries_boundary, keep = 0.05)
countries_sf_valid <- st_make_valid(countries_sf_simplified)
countries_wrapped <- st_wrap_dateline(countries_sf_valid)
polygon <- st_polygon(x = list(rbind(
  c(-180.0001, 90),
  c(-179.9999, 90),
  c(-179.9999, -90),
  c(-180.0001, -90),
  c(-180.0001, 90)
))) |>
  st_sfc() |>
  st_set_crs(4326)

countries_wrapped <- countries_wrapped |>
  st_difference(polygon)


land_sf <- read_sf("data/WB_Land.geojson")
land_boundary <- st_boundary(land_sf)
land_sf_simplified <- ms_simplify(land_boundary, keep = 0.05)
land_sf_valid <- st_make_valid(land_sf_simplified)
land_wrapped <- st_wrap_dateline(land_sf_valid)
polygon <- st_polygon(x = list(rbind(
  c(-180.0001, 90),
  c(-179.9999, 90),
  c(-179.9999, -90),
  c(-180.0001, -90),
  c(-180.0001, 90)
))) |>
  st_sfc() |>
  st_set_crs(4326)

land_wrapped <- land_wrapped |>
  st_difference(polygon)

countries_wrapped <- countries_wrapped |>
  st_difference(polygon)
```

```{r}
# Washing data combined
countries_sf_water <- left_join(
  countries_wrapped,
  proportion_of_safe_water_map,
  by = c("WB_A3" = "iso")
)
# countries_sf_water

# Mortality Rate Combined
countries_sf_mortality <- left_join(
  countries_wrapped,
  mr_unsafe_water_map,
  by = c("WB_A3" = "iso")
)

# countries_sf_mortality
```


```{r}
# Get the different values for all areas, urban and rural in water management

countries_sf_water_all <- countries_sf_water %>% filter(!(urbanisation %in% c("Rural", "Urban")))
countries_sf_water_urban <- countries_sf_water %>% filter(!(urbanisation %in% c("All area", "Urban")))
countries_sf_water_rural <- countries_sf_water %>% filter(!(urbanisation %in% c("Urban", "All areas")))
```

```{r}
# Load the required libraries
library(leaflet)

# Define the color palette function
colorPalette <- colorRampPalette(c("#FF6969", "#00A0D6"))


# Generate the color palette based on the number of breaks
numBreaks <- 6
colors <- colorPalette(numBreaks)

# Create a Leaflet map
all_map <- leaflet(countries_sf_water_all) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    fillColor = ~ colorNumeric(palette = colors, domain = c(0, 20, 40, 60, 80, 100))(value_2019),
    fillOpacity = 0.8,
    weight = 2,
    opacity = 1,
    color = "white",
    dashArray = "3",
    highlight = highlightOptions(
      weight = 5,
      color = "#666",
      dashArray = "",
      fillOpacity = 0.7,
      bringToFront = TRUE
    ),
    label = ~WB_A3,
    popup = ~ paste(
      "Country Code: ", WB_A3,
      "<br>Country: ", country,
      "<br>Proportion of population access to safely managed drinking water service: ",
      value_2019
    )
  ) %>%
  addLegend(
    position = "bottomright",
    pal = colorNumeric(palette = colors, domain = c(0, 100)),
    values = c(0, 20, 40, 60, 80, 100),
    title = "Proportion (%)",
    labels = c("0-20", "20-40", "40-60", "60-80", "80-100"),
    opacity = 1
  )

all_map
```


## Map: Safely managed drinking water proportion (6.1.1): Urban areas

```{r}
# Define the color palette function
colorPalette <- colorRampPalette(c("#FF6969", "#00A0D6"))


# Generate the color palette based on the number of breaks
numBreaks <- 6
colors <- colorPalette(numBreaks)

# Create a Leaflet map
urban_map <- leaflet(countries_sf_water_urban) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    fillColor = ~ colorNumeric(
      palette = colors,
      domain = c(0, 20, 40, 60, 80, 100)
    )(value_2019),
    fillOpacity = 0.8,
    weight = 2,
    opacity = 1,
    color = "white",
    dashArray = "3",
    highlight = highlightOptions(
      weight = 5,
      color = "#666",
      dashArray = "",
      fillOpacity = 0.7,
      bringToFront = TRUE
    ),
    label = ~WB_A3,
    popup = ~ paste(
      "Country Code: ", WB_A3,
      "<br>Country: ", country,
      "<br>Proportion of population access to safely managed drinking water service: ",
      value_2019
    )
  ) %>%
  addLegend(
    position = "bottomright",
    pal = colorNumeric(palette = colors, domain = c(0, 100)),
    values = c(0, 20, 40, 60, 80, 100),
    title = "Proportion (%)",
    labels = c("0-20", "20-40", "40-60", "60-80", "80-100"),
    opacity = 1
  )

urban_map
```

## Map: Safely managed drinking water proportion (6.1.1): Rural areas

```{r}
# Define the color palette function
colorPalette <- colorRampPalette(c("#FF6969", "#00A0D6"))


# Generate the color palette based on the number of breaks
numBreaks <- 6
colors <- colorPalette(numBreaks)

# Create a Leaflet map
rural_map <- leaflet(countries_sf_water_rural) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    fillColor = ~ colorNumeric(palette = colors, domain = c(0, 20, 40, 60, 80, 100))(value_2019),
    fillOpacity = 0.8,
    weight = 2,
    opacity = 1,
    color = "white",
    dashArray = "3",
    highlight = highlightOptions(
      weight = 5,
      color = "#666",
      dashArray = "",
      fillOpacity = 0.7,
      bringToFront = TRUE
    ),
    label = ~WB_A3,
    popup = ~ paste(
      "Country Code: ", WB_A3,
      "<br>Country: ", country,
      "<br>Proportion of population access to safely managed drinking water service: ",
      value_2019
    )
  ) %>%
  addLegend(
    position = "bottomright",
    pal = colorNumeric(palette = colors, domain = c(0, 100)),
    values = c(0, 20, 40, 60, 80, 100),
    title = "Proportion (%)",
    labels = c("0-20", "20-40", "40-60", "60-80", "80-100"),
    opacity = 1
  )

rural_map
```

## Map: Water, sanitation, hygiene mortality rate (3.9.2)

```{r}
# Define the color palette function
colorPalette <- colorRampPalette(c("#FFFFDF", "#FFEEAA", "#FFBB55", "#FF7700", "#FF4400"))


# Generate the color palette based on the number of breaks
numBreaks <- 6
colors <- colorPalette(numBreaks)

# Create a Leaflet map
mortality_mapping <- leaflet(countries_sf_mortality) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    fillColor = ~ colorNumeric(palette = colors, domain = c(0, 20, 40, 60, 80, 100))(mortality_rate_unsafe_water),
    fillOpacity = 0.8,
    weight = 2,
    opacity = 1,
    color = "grey",
    dashArray = "3",
    highlight = highlightOptions(
      weight = 5,
      color = "#666",
      dashArray = "",
      fillOpacity = 0.7,
      bringToFront = TRUE
    ),
    label = ~WB_A3,
    popup = ~ paste(
      "Country Code: ", WB_A3,
      "<br>Country: ", country,
      "<br>Mortality Rate from Unsafe Sanitation and Water per 100,000: ", mortality_rate_unsafe_water
    )
  ) %>%
  addLegend(
    position = "bottomright",
    pal = colorNumeric(palette = colors, domain = c(0, 100)),
    values = c(0, 20, 40, 60, 80, 100),
    title = "Proportion (100, 000)",
    labels = c("0-20", "20-40", "40-60", "60-80", "80-100"),
    opacity = 1
  )

mortality_mapping
```


## Mortality Rate vs Water Services

```{r}
merged_data <- merge(mortality_rate_unsafe_water, proportion_of_safe_water, by = c("geoAreaCode", "geoAreaName"))
merged_data <- merged_data[!is.na(merged_data$value_2019), ] # remove NA values for 2019
```

```{r}
# Correlation

# Plot the data
plot_loess <- ggplot(merged_data, aes(x = latest_value.x, y = value_2019)) +
  geom_point(aes(
    color = location_desc,
    shape = location_desc,
    text = paste("Country:", geoAreaName, "<br>", "Location:", location_desc)
  ), alpha = 0.7) +
  geom_smooth(
    data = subset(merged_data, location_desc == "All areas"),
    method = loess, se = FALSE,
    aes(color = location_desc, weight = value_2019),
    show.legend = TRUE
  ) +
  geom_smooth(
    data = subset(merged_data, location_desc == "Urban"),
    method = loess,
    se = FALSE,
    aes(color = location_desc, weight = value_2019),
    show.legend = TRUE
  ) +
  geom_smooth(
    data = subset(merged_data, location_desc == "Rural"),
    method = loess,
    se = FALSE,
    aes(color = location_desc, weight = value_2019),
    show.legend = TRUE
  ) +
  labs(
    x = "Mortality Rate (deaths per 100,000 population)",
    y = "Safely Managed Drinking Water Services (%)",
    title = "Correlation between Mortality Rate and Water Services (2019)",
    color = "Location Type",
    shape = "Location Type"
  ) +
  theme_minimal() +
  guides(
    color = guide_legend(override.aes = list(shape = 16)),
    shape = guide_legend(override.aes = list(color = "black"))
  )


# Convert to a plotly plot
gp <- ggplotly(plot_loess, tooltip = "text")

# Print the plot
# gp
```

```{r}
correlation_all <- cor(
  merged_data$latest_value.x[merged_data$location_desc == "All areas"],
  merged_data$value_2019[merged_data$location_desc == "All areas"]
)

correlation_urban <- cor(
  merged_data$latest_value.x[merged_data$location_desc == "Urban"],
  merged_data$value_2019[merged_data$location_desc == "Urban"]
)

correlation_rural <- cor(
  merged_data$latest_value.x[merged_data$location_desc == "Rural"],
  merged_data$value_2019[merged_data$location_desc == "Rural"]
)

blank_plot <- ggplot() +
  theme_void() +
  theme(plot.margin = margin(1, 1, 1, 1, "cm")) +
  annotate("text",
    x = 0.5,
    y = 0.5,
    label = paste(
      "Correlation All:",
      round(correlation_all, 2), "\n",
      "Correlation Urban:",
      round(correlation_urban, 2), "\n",
      "Correlation Rural:",
      round(correlation_rural, 2)
    ),
    size = 5,
    color = "black",
    hjust = 0.5
  )

# Convert to a plotly plot
gp_text <- ggplotly(blank_plot)
# gp_text
```

```{r}
# Barchart and stacked barchart (without Transformation)

stacked_bar_chart <- ggplot(merged_data, aes(x = latest_value.x, fill = location_desc)) +
  geom_histogram(position = "stack", bins = 20) +
  labs(
    x = "Mortality Rate (deaths per 100,000 population)",
    y = "Count",
    title = "Stacked Bar Chart of Mortality Rates"
  ) +
  theme_minimal()

# change to plotly
ggplot_stacked_bar_chart <- ggplotly(stacked_bar_chart)
# ggplot_stacked_bar_chart

grouped_bar_chart <- ggplot(merged_data, aes(x = latest_value.x, fill = location_desc)) +
  geom_histogram(position = "dodge", bins = 20) +
  labs(
    x = "Mortality Rate (deaths per 100,000 population)",
    y = "Count",
    title = "Grouped Bar Chart of Mortality Rates"
  ) +
  theme_minimal()

# Convert to a plotly plot
ggplot_grouped_bar_chart <- ggplotly(grouped_bar_chart)
# ggplot_grouped_bar_chart
```

```{r}
# Filter data for the histogram
merged_data_all <- subset(merged_data, location_desc == "All areas") # change to rural or urban if you want

histogram <- ggplot(merged_data_all, aes(
  x = latest_value.x,
  text = paste(
    "Country:", geoAreaName,
    "<br>Mortality Rate:", latest_value.x
  )
)) +
  geom_histogram(bins = 50, fill = "grey", color = "black") +
  labs(
    x = "Mortality Rate (deaths per 100,000 population)",
    y = "Count",
    title = 'Histogram of Mortality Rates for "All" locations'
  ) +
  theme_minimal()

# Convert ggplot histogram to a plotly plot
plotly_histogram <- ggplotly(histogram, tooltip = "text")
```

```{r}
#| include: false

# Normalise Data

merged_data$latest_value.x_positive <- merged_data$latest_value.x + abs(min(merged_data$latest_value.x)) + 0.1

# Apply the Box-Cox transformation
bc_result <- MASS::boxcox(merged_data$latest_value.x_positive ~ 1,
  lambda = seq(-3, 3, 0.1)
)

# The optimal lambda value is the one that maximizes the log-likelihood
optimal_lambda <- bc_result$x[which.max(bc_result$y)]

# Transform the data using the optimal lambda value
if (optimal_lambda == 0) {
  merged_data$latest_value.x_bc <- log(merged_data$latest_value.x_positive)
} else {
  merged_data$latest_value.x_bc <- (merged_data$latest_value.x_positive^optimal_lambda - 1) / optimal_lambda
}

# Shift the transformed variable to be non-negative
min_value <- min(merged_data$latest_value.x_bc)
merged_data$latest_value.x_bc <- merged_data$latest_value.x_bc + abs(min_value) + 0.1
```

```{r}
# Histogram (Normalised)

# Round the transformed mortality rates to the nearest whole number
merged_data$latest_value.x_bc_rounded <- round(merged_data$latest_value.x_bc)

# Convert the latest_value.x_bc_rounded variable into a categorical variable
merged_data$latest_value.x_bc_cat <- cut(merged_data$latest_value.x_bc_rounded, breaks = 50)

# Create a stacked bar chart
stacked_bar_chart_bc <- ggplot(merged_data, aes(x = latest_value.x_bc_rounded, fill = location_desc)) +
  geom_bar(position = "stack", bins = 20) +
  labs(
    x = "Transformed Mortality Rate",
    y = "Count",
    title = "Stacked Bar Chart of Transformed Mortality Rates"
  ) +
  theme_minimal()

ggplot_stacked_bar_chart_bc <- ggplotly(stacked_bar_chart_bc)
# ggplot_stacked_bar_chart_bc

# Create a grouped bar chart
grouped_bar_chart_bc <- ggplot(merged_data, aes(x = latest_value.x_bc_rounded, fill = location_desc)) +
  geom_bar(position = "dodge") +
  labs(
    x = "Transformed Mortality Rate",
    y = "Count",
    title = "Grouped Bar Chart of Transformed Mortality Rates"
  ) +
  theme_minimal()

# Convert to a plotly plot
ggplot_grouped_bar_chart_bc <- ggplotly(grouped_bar_chart_bc)
# ggplot_grouped_bar_chart_bc
```

```{r}
# Scatter plot Normalised
plot_loess <- ggplot(merged_data, aes(x = latest_value.x_bc, y = value_2019)) +
  geom_point(aes(
    color = location_desc,
    shape = location_desc,
    text = paste("Country:", geoAreaName, "<br>", "Location:", location_desc)
  ), alpha = 0.7) +
  geom_smooth(
    data = subset(merged_data, location_desc == "All areas"),
    method = loess, se = FALSE,
    aes(color = location_desc, weight = value_2019),
    show.legend = TRUE
  ) +
  geom_smooth(
    data = subset(merged_data, location_desc == "Urban"),
    method = loess,
    se = FALSE,
    aes(color = location_desc, weight = value_2019),
    show.legend = TRUE
  ) +
  geom_smooth(
    data = subset(merged_data, location_desc == "Rural"),
    method = loess,
    se = FALSE,
    aes(color = location_desc, weight = value_2019),
    show.legend = TRUE
  ) +
  labs(
    x = "Transformed Mortality Rate (deaths per 100,000 population)",
    y = "Safely Managed Drinking Water Services (%)",
    title = "Correlation between Transformed Mortality Rate and Water Services (Normalised)",
    color = "Location Type",
    shape = "Location Type"
  ) +
  theme_minimal() +
  guides(
    color = guide_legend(override.aes = list(shape = 16)),
    shape = guide_legend(override.aes = list(color = "black"))
  )


gp_normalised <- ggplotly(plot_loess, tooltip = "text")
# gp_normalised
```

```{r}
# Correlation normalised
correlation_all <- cor(
  merged_data$latest_value.x_bc[merged_data$location_desc == "All areas"],
  merged_data$value_2019[merged_data$location_desc == "All areas"]
)

correlation_urban <- cor(
  merged_data$latest_value.x_bc[merged_data$location_desc == "Urban"],
  merged_data$value_2019[merged_data$location_desc == "Urban"]
)

correlation_rural <- cor(
  merged_data$latest_value.x_bc[merged_data$location_desc == "Rural"],
  merged_data$value_2019[merged_data$location_desc == "Rural"]
)

blank_plot <- ggplot() +
  theme_void() +
  theme(plot.margin = margin(1, 1, 1, 1, "cm")) +
  annotate("text",
    x = 0.5,
    y = 0.5,
    label = paste(
      "Correlation All:",
      round(correlation_all, 2), "\n",
      "Correlation Urban:",
      round(correlation_urban, 2), "\n",
      "Correlation Rural:",
      round(correlation_rural, 2)
    ),
    size = 5,
    color = "black",
    hjust = 0.5
  )

gp_text_normalised <- ggplotly(blank_plot)
# gp_text_normalised
```

```{r}
# Combining normal and unnormalised plots

combined_plot <- subplot(
  gp, gp_text,
  gp_normalised, gp_text_normalised,
  nrows = 2, margin = 0.05
)

combined_plot
```


## Mortality Rate vs Water Services


```{r}
subplot <- subplot(ggplot_stacked_bar_chart, ggplot_grouped_bar_chart, nrows = 1)
subplot
```

## Mortality Rate vs Water Services (Normalised)

```{r}
subplot_normalised <- subplot(ggplot_stacked_bar_chart_bc, ggplot_grouped_bar_chart_bc, nrows = 1)
subplot_normalised
```



## Table of all countries representation {.smaller .scrollable}

```{r}
# mortality_rate_attributed_to_unsafe_water
mr_unsafe_water_indicators <- read_csv("data/indicator_3.9.2.csv", show_col_types = FALSE)

# Proportion_of_population_using_safely_managed_drinking_water_services
prop_of_safe_water_indicators <- read_csv("data/indicator_6.1.1.csv",
  show_col_types = FALSE
)

# unintentional_poisoning
unintentional_poi_ind <- read_csv("data/indicator_3.9.3.csv",
  show_col_types = FALSE
)

# proportion-of-population-with-basic-handwashing-facilities-on-premises-by-urban-rural-percent
handwashing_facil_ind <- read_csv("data/indicator_6.2.1.csv",
  show_col_types = FALSE
)
```

```{r}
mr_unsafe_water_indicators <- dplyr::select(
  mr_unsafe_water_indicators,
  code = "geoAreaCode",
  country = "geoAreaName",
  region = "parentName",
  iso = "ISO3",
  MR_unsafe_water = "latest_value"
)

mr_unsafe_water_indicators <- mr_unsafe_water_indicators %>%
  distinct()

# mr_unsafe_water_indicators
```

```{r}
prop_of_safe_water_indicators <- dplyr::select(
  prop_of_safe_water_indicators,
  code = "geoAreaCode",
  country = "geoAreaName",
  region = "parentName",
  iso = "ISO3",
  urbanisation = "location_desc",
  sanitation_access = "value_2019",
)

# Remove duplicates
prop_of_safe_water_indicators <- prop_of_safe_water_indicators %>%
  distinct()

# prop_of_safe_water_indicators
```

```{r}
#| include: false
lint <- function(file) {
  return(numeric(0))
}
```

```{r}
#| label: select specific columns for mortality rate
unintentional_poi_ind <- dplyr::select(
  unintentional_poi_ind,
  code = "geoAreaCode",
  country = "geoAreaName",
  region = "parentName",
  iso = "ISO3",
  gender = "sex_desc",
  MR_poisoning = "value_2019"
)

# drop rows if contains at least one NA value
unintentional_poi_ind <- na.omit(unintentional_poi_ind)

# Remove duplicates
unintentional_poi_ind <- unintentional_poi_ind %>%
  distinct()
```

```{r}
#| label: select specific columns for population with basic handwashing facilities
handwashing_facil_ind <- dplyr::select(
  handwashing_facil_ind,
  code = "geoAreaCode",
  country = "geoAreaName",
  region = "parentName",
  iso = "ISO3",
  urbanisation = "location_desc",
  handwash_access = "value_2019"
)

# drop rows if contains at least one NA value
handwashing_facil_ind <- na.omit(handwashing_facil_ind)

# Remove duplicates
handwashing_facil_ind <- handwashing_facil_ind %>%
  distinct()
```


```{r}
#| warning: false

# Joining all 4 indicators

countries_tb <- left_join(
  unintentional_poi_ind,
  handwashing_facil_ind,
  by = join_by(country, iso)
)

countries_tb <- left_join(
  countries_tb,
  mr_unsafe_water_indicators,
  by = join_by(iso)
)

countries_tb <- left_join(
  countries_tb,
  prop_of_safe_water_indicators,
  by = join_by(iso, urbanisation)
) |>
  mutate(
    iso = case_match(
      iso,
      "COD" ~ "ZAR",
      "ROU" ~ "ROM",
      "TLS" ~ "TMP",
      "XKX" ~ "KSV",
      .default = iso
    )
  )
```


```{r}
# Joining with adminGeoJson

countries_sf <- read_sf("./data/WB_countries_Admin0.geojson")
countries_tb <- left_join(
  countries_tb,
  dplyr::select(countries_sf, WB_A3, GDP_MD_EST, INCOME_GRP, POP_EST),
  by = c("iso" = "WB_A3")
)
```

```{r}
# countries_tb
```

```{r}
#| fig-width: 3.5
#| fig-height: 3.5

# Clean data
# Remove certain columns and rename column for cleaner a look

# Drop
clean_datatable <- dplyr::select(
  countries_tb,
  -code.y, -code.x,
  -region.y, -region.x,
  -code.x.x, code.y.y,
  -country.x, -country.y,
  -region.x.x, -region.y.y,
  -iso
)
# Rename
clean_datatable <- clean_datatable %>% rename(
  gdp = GDP_MD_EST,
  income_group = INCOME_GRP,
  population = POP_EST
)

# Rearrange
clean_datatable <- clean_datatable %>%
  dplyr::select(
    country,
    gdp,
    income_group,
    population,
    urbanisation,
    gender,
    handwash_access,
    sanitation_access,
    MR_poisoning,
    MR_unsafe_water,
  )
```

```{r}
#| out-width: 25%
datatable(clean_datatable)
```

## Correlation between all 4 indicators

```{r}
# filter gender of both sexes to reduce duplicates
countries_tb <- countries_tb |>
  filter(gender == "Both sexes") |>
  na.omit(countries_tb)
# countries_tb
```

```{r}
countries_tb_subset <- dplyr::select(countries_tb, MR_poisoning, MR_unsafe_water, handwash_access, sanitation_access, urbanisation, country.x)
```


```{r}
# Scatterplot matrix

# set axis names
countries_tb_subset_corr4 <- dplyr::select(countries_tb_subset, MR_unsafe_water, MR_poisoning, handwash_access, sanitation_access, urbanisation, country.x)
colnames(countries_tb_subset_corr4) <- c(
  "Unsafe Water Mortality Rate",
  "Poisoning Mortality",
  "Handwashing Access (%)",
  "Sanitation Access (%)",
  "Urbanisation",
  "Countries"
)
# countries_tb_subset_corr4

# change to factor for colour
countries_tb_subset_corr4$Urbanisation <- as.factor(countries_tb_subset_corr4$Urbanisation)

plot <- ggpairs(
  data = countries_tb_subset_corr4,
  columns = 1:4,
  upper = list(continuous = "cor"),
  lower = list(continuous = "smooth", se = FALSE),
  diag = list(continuous = "bar", bin = 30),
  mapping = aes(color = Urbanisation),
  tooltips = c("Countries")
) +
  theme_minimal() +
  theme(axis.title = element_text(size = 5))

# plot
```

```{r}
# Convert ggplot to plotly
plot_interactive <- ggplotly(plot)

plot_interactive <- layout(plot_interactive,
  font = list(size = 8)
)

# Render the plotly scatterplot matrix
plot_interactive
```

```{r}
#| include: false

# Different Scatter plot matrix

countries_tb_subset_corr4 <- dplyr::select(countries_tb_subset, MR_unsafe_water, MR_poisoning, handwash_access, sanitation_access, urbanisation)

# Rename the columns
colnames(countries_tb_subset_corr4) <- c(
  "Unsafe Water Mortality Rate",
  "Poisoning Mortality",
  "Handwashing Access (%)",
  "Sanitation Access (%)",
  "Urbanisation"
)

# Make urbanisation as a factor for colourisation
countries_tb_subset_corr4$Urbanisation <- as.factor(countries_tb_subset_corr4$Urbanisation)

# Map urbanisation to colors
color_mapping <- c("All areas" = "red", "Urban" = "blue", "Rural" = "green") # Adjust to your actual factor levels and desired colors
colors <- color_mapping[countries_tb_subset_corr4$Urbanisation]

# Create scatterplot matrix without colors
plot <- pairs.panels(countries_tb_subset_corr4[, 1:4],
  hist.col = "#00AFBB",
  bg = "transparent"
)
```

## $\textit{k}$-Means Clustering

```{r}
#| include: false

# Scaling the dataset
df <- clean_datatable |>
  dplyr::filter(urbanisation == "All areas", gender == "Both sexes") |>
  dplyr::select(-urbanisation, -gender, -gdp) |>
  na.omit()

kable(head((df)))

numeric_cols <-
  c(
    "handwash_access",
    "sanitation_access",
    "MR_poisoning",
    "MR_unsafe_water"
  )
numeric_df <- df[numeric_cols]
scaled_df <- scale(numeric_df)
kable(head((scaled_df)))
```

Considering the four selected Sustainable Development Goals, what is an appropriate number, $\textit{k}$, of clusters for countries?

::: columns

::: {.column width="70%"}
```{r}
# Elbow Criterion

fviz_nbclust(scaled_df, kmeans, method = "wss")
```

```{r}
#| include: false
# Do k-means clustering for dataset

scaled_df_table <- data.table(scaled_df)
k <- kmeans(scaled_df_table, centers = 3)
scaled_df_table[, cluster := as.factor(k$cluster)]

country <- df$country
income_group <- df$income_group
population <- df$population
scaled_df_table_with_country <-
  cbind(population, income_group, country, scaled_df_table)

kable(head(scaled_df_table_with_country))
```
:::

::: {.column width="3%"}
:::

::: {.column width="27%"}
Elbow at 3, so we choose k=3
:::

:::


## Pairs Plot Highlighting Clusters

```{r}
# Create pair plot highlighting clusters

ggpair_plt <- ggpairs(
  scaled_df_table_with_country,
  aes(colour = cluster, text = country),
  diag = list(continuous = "barDiag"),
  columns = c(
    "handwash_access",
    "sanitation_access",
    "MR_poisoning",
    "MR_unsafe_water"
  ),
  columnLabels = c(
    "% Hand-wash\n Facility",
    "% Safe Drinking\n Water",
    "% Death by\n Posion",
    "% Death by\n Unsafe Water"
  )
)
```

::: columns

::: {.column width="80%"}

```{r}
#| fig-height: 6

ggplotly_plot <- ggplotly(ggpair_plt, tooltip = c("country"))
ggplotly_plot
```

:::

::: {.column width="3%"}
:::

::: {.column width="17%"}

::: {style="color: red; font-size: 80%;"}
1. Low mortality rate 
:::

::: {style="color: green; font-size: 80%;"}
2. High sanitation and Low mortality rate
:::

::: {style="color: blue; font-size: 80%;"}
3. Low sanitation and High mortality rate
:::

:::

:::


## Decision Tree {.smaller}

Can the cluster assignment be predicted based on the countrys income group, population size and region according to the 7-class World Bank categorisation?


```{r}
#| include: false

# Add country code to dataset

scaled_df_table_with_cc <-
  scaled_df_table_with_country |>
  mutate(code = countrycode(country, origin = "country.name", destination = "wb"))
kable(head(scaled_df_table_with_cc))

any_na <- any(is.na(scaled_df_table_with_cc))
# any_na
```

```{r}
#| include: false

countries_sf <- read_sf("./data/WB_countries_Admin0.geojson")
countries_sf <- st_drop_geometry(countries_sf) |>
  dplyr::select(WB_A3, REGION_WB)

dataset <-
  merge(scaled_df_table_with_cc,
    countries_sf,
    by.x = "code",
    by.y = "WB_A3"
  )
kable(head(dataset))

any_na <- any(is.na(dataset))
# any_na

dplyr::glimpse(dataset)
```

```{r}
#| include: false

# Create factor vairables for dataset

shuffle_index <- sample(1:nrow(dataset))
dataset <- dataset[shuffle_index, ]

column_types <- sapply(dataset, class)

unique(dataset$REGION_WB)
unique(dataset$income_group)

setnames(dataset, "REGION_WB", "region")

dataset <- dataset[, c("cluster", "region", "income_group", "population")]

dataset$income_group <- factor(
  dataset$income_group,
  levels = c(
    "5. Low income",
    "4. Lower middle income",
    "3. Upper middle income",
    "2. High income: nonOECD"
  ),
  labels = c("low", "lower middle", "upper middle", "high")
)

dataset$region <- factor(
  dataset$region,
  levels = c(
    "Sub-Saharan Africa",
    "South Asia",
    "Middle East & North Africa",
    "Europe & Central Asia",
    "East Asia & Pacific",
    "Latin America & Caribbean"
  ),
  labels = c(
    "Sub-Saharan Africa",
    "South Asia",
    "Middle East & North Africa",
    "Europe & Central Asia",
    "East Asia & Pacific",
    "Latin America & Caribbean"
  )
)

any_na <- any(is.na(dataset))
# any_na

clean_dataset <- dataset
dplyr::glimpse(clean_dataset)
```

```{r}
# Train decision tree

train_rows <-
  createDataPartition(clean_dataset$cluster, p = 0.75, list = FALSE)
train <- clean_dataset[train_rows, ]
test <- clean_dataset[-train_rows, ]

tree_model <- rpart(cluster ~ ., data = train, method = "class")

split_fun <- function(x, labs, digits, varlen, faclen) {
  for (i in 1:length(labs)) {
    labs[i] <- paste(strwrap(labs[i], width = 40), collapse = "\n")
  }
  labs
}

rpart.plot(tree_model,
  extra = 102,
  digits = -3,
  split.fun = split_fun
)
```

The decision tree only considered the region variable for classification.

## Evaluation of Decision Tree {.smaller}

```{r}
#| include: false

# Relative importance

rel_impt <- as.data.frame(tree_model$variable.importance)
rel_impt
```

Relative importance of the predictors for classification are as follows:

- Region: 18.01
- Income: 6.49
- Population size: 1.74


```{r}
#| include: false

# Prediction with decision tree

set.seed(12345)
prediction <- predict(tree_model, newdata = test, type = "class")
confMatrix <- table(prediction, test$cluster)
confMatrix
accuracy <- sum(diag(confMatrix)) / sum(confMatrix)
print(paste("Accuracy: ", accuracy))
```
<br/>
Observations:

- For a single train-test split of \[75 25\], the model obtained a decent prediction accuracy of 0.7.

```{r}
#| include: false

# Ten-fold cross validation

train_control <- trainControl(
  method = "cv", # Use cross validation
  number = 10
) # Use 10 folds

# tune_grid = expand.grid(cp=c(0.0001)) # complexity parameter (size of tree)

validated_tree <- train(cluster ~ .,
  data = clean_dataset,
  method = "rpart",
  trControl = train_control
)

validated_tree
validated_tree$resample
```

- However, the accuracy for ten-fold cross validation was low, at 0.58.
- This is probably because the dataset is too small, and the model is overfitting.
- Overall, the model is unable to generalize to unseen data.**


## Summary of Quantitative Results

- Hygiene factors (handwashing facilities and safe drinking water) have significant **negative correlations** with mortality rates (per 100,000 population).
- Access to handwashing facilities shows a **strong inverse relationship** with mortality rates (correlation coefficient: -0.7) for all areas.
- Access to safely managed drinking water is **strongly negatively correlated** with mortality rates (correlation coefficient: -0.87) for all areas


## Policy Implications

- Importance of handwashing facilities and safe drinking water in lowering mortality rates, especially related to unsafe water.
- Urgency for public health policies to expand access to these essential facilities and services.
- Valuable insights for policy-making bodies on the significant impact of investments in handwashing and safe water.
- Overall, these findings highlight the importance of prioritizing these interventions to reduce mortality rates effectively.

# End

```{r}
#| label: lint

length(lint("slides.qmd"))
```
